<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>消息队列 | 跳跳猪</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/logo.jpg">
    <meta name="description" content="吃得好，睡得好">
    
    <link rel="preload" href="/assets/css/0.styles.542f065b.css" as="style"><link rel="preload" href="/assets/js/app.9ac200f5.js" as="script"><link rel="preload" href="/assets/js/2.f08c2e94.js" as="script"><link rel="preload" href="/assets/js/50.487406c6.js" as="script"><link rel="prefetch" href="/assets/js/10.104e03e5.js"><link rel="prefetch" href="/assets/js/11.18d17b89.js"><link rel="prefetch" href="/assets/js/12.31c398a8.js"><link rel="prefetch" href="/assets/js/13.b5ee2d7d.js"><link rel="prefetch" href="/assets/js/14.a60f524e.js"><link rel="prefetch" href="/assets/js/15.55fd61b8.js"><link rel="prefetch" href="/assets/js/16.7aa17999.js"><link rel="prefetch" href="/assets/js/17.24758699.js"><link rel="prefetch" href="/assets/js/18.0b71a4f7.js"><link rel="prefetch" href="/assets/js/19.4770b075.js"><link rel="prefetch" href="/assets/js/20.fe4d448c.js"><link rel="prefetch" href="/assets/js/21.6ef119a3.js"><link rel="prefetch" href="/assets/js/22.68798857.js"><link rel="prefetch" href="/assets/js/23.a8a337ba.js"><link rel="prefetch" href="/assets/js/24.c156d0fe.js"><link rel="prefetch" href="/assets/js/25.b840f4b8.js"><link rel="prefetch" href="/assets/js/26.37c5f756.js"><link rel="prefetch" href="/assets/js/27.5b776d07.js"><link rel="prefetch" href="/assets/js/28.4d89a988.js"><link rel="prefetch" href="/assets/js/29.d8405b8b.js"><link rel="prefetch" href="/assets/js/3.98efb80c.js"><link rel="prefetch" href="/assets/js/30.67c25a87.js"><link rel="prefetch" href="/assets/js/31.cd45304b.js"><link rel="prefetch" href="/assets/js/32.b0bff8a4.js"><link rel="prefetch" href="/assets/js/33.b8e0beb7.js"><link rel="prefetch" href="/assets/js/34.eedead55.js"><link rel="prefetch" href="/assets/js/35.44fef23e.js"><link rel="prefetch" href="/assets/js/36.3e7830e5.js"><link rel="prefetch" href="/assets/js/37.8f711bb3.js"><link rel="prefetch" href="/assets/js/38.3b7df8b6.js"><link rel="prefetch" href="/assets/js/39.a7dfb50c.js"><link rel="prefetch" href="/assets/js/4.2e894fd2.js"><link rel="prefetch" href="/assets/js/40.ba597a3a.js"><link rel="prefetch" href="/assets/js/41.0955ce39.js"><link rel="prefetch" href="/assets/js/42.b1629e72.js"><link rel="prefetch" href="/assets/js/43.606f57ec.js"><link rel="prefetch" href="/assets/js/44.5e8f4801.js"><link rel="prefetch" href="/assets/js/45.fc255c2f.js"><link rel="prefetch" href="/assets/js/46.9222248d.js"><link rel="prefetch" href="/assets/js/47.d6bf833e.js"><link rel="prefetch" href="/assets/js/48.40e23b48.js"><link rel="prefetch" href="/assets/js/49.ba7c2b8d.js"><link rel="prefetch" href="/assets/js/5.d2ef2a1a.js"><link rel="prefetch" href="/assets/js/51.3f8ea397.js"><link rel="prefetch" href="/assets/js/52.acd66974.js"><link rel="prefetch" href="/assets/js/53.58c7fc05.js"><link rel="prefetch" href="/assets/js/54.0f8282f4.js"><link rel="prefetch" href="/assets/js/55.ad7bb205.js"><link rel="prefetch" href="/assets/js/56.590655d9.js"><link rel="prefetch" href="/assets/js/57.9a85aa7a.js"><link rel="prefetch" href="/assets/js/58.1b4ef9fd.js"><link rel="prefetch" href="/assets/js/59.9420c0ba.js"><link rel="prefetch" href="/assets/js/6.65a955fd.js"><link rel="prefetch" href="/assets/js/60.30009201.js"><link rel="prefetch" href="/assets/js/61.0047220f.js"><link rel="prefetch" href="/assets/js/62.a368a893.js"><link rel="prefetch" href="/assets/js/63.3315d70a.js"><link rel="prefetch" href="/assets/js/64.3e3c478f.js"><link rel="prefetch" href="/assets/js/65.80a47305.js"><link rel="prefetch" href="/assets/js/66.ae967862.js"><link rel="prefetch" href="/assets/js/67.606a99c5.js"><link rel="prefetch" href="/assets/js/68.46eb6539.js"><link rel="prefetch" href="/assets/js/69.c6067a0e.js"><link rel="prefetch" href="/assets/js/7.ed4f4e88.js"><link rel="prefetch" href="/assets/js/8.517c5e6e.js"><link rel="prefetch" href="/assets/js/9.bef30b40.js">
    <link rel="stylesheet" href="/assets/css/0.styles.542f065b.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu have-body-img"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://excalidraw.com/apple-touch-icon.png" alt="跳跳猪" class="logo"> <span class="site-name can-hide">跳跳猪</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/md/java/JAVA基础.html" class="nav-link">JAVA</a></div><div class="nav-item"><a href="/md/database/mysql/MySql操作.html" class="nav-link">数据库</a></div><div class="nav-item"><a href="/md/opSystem/linux/linux操作笔记.html" class="nav-link">操作系统</a></div><div class="nav-item"><a href="/md/middleware/mq/消息队列.html" class="nav-link">中间件</a></div><div class="nav-item"><a href="/md/tool/docker/docker.html" class="nav-link">开发工具</a></div><div class="nav-item"><a href="/md/designPattern/" class="nav-link">设计模式</a></div><div class="nav-item"><a href="/md/netty/BIO、NIO、AIO.html" class="nav-link">netty</a></div><div class="nav-item"><a href="/md/DDD/小傅哥案例学习打卡/DDD抽奖系统学习打卡🚀 day 1.html" class="nav-link">DDD</a></div><div class="nav-item"><a href="/md/other/面试题.html" class="nav-link">other</a></div><div class="nav-item"><a href="/md/notes/" class="nav-link">测试</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="提示语" class="dropdown-title"><!----> <span class="title" style="display:;">测试下拉菜单</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/notes/" class="nav-link">菜单1</a></li><li class="dropdown-item"><!----> <a href="/md/notes/" class="nav-link">菜单2</a></li><li class="dropdown-item"><h4>多次菜单</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/md/notes/" class="nav-link">多级菜单1</a></li></ul></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/md/java/JAVA基础.html" class="nav-link">JAVA</a></div><div class="nav-item"><a href="/md/database/mysql/MySql操作.html" class="nav-link">数据库</a></div><div class="nav-item"><a href="/md/opSystem/linux/linux操作笔记.html" class="nav-link">操作系统</a></div><div class="nav-item"><a href="/md/middleware/mq/消息队列.html" class="nav-link">中间件</a></div><div class="nav-item"><a href="/md/tool/docker/docker.html" class="nav-link">开发工具</a></div><div class="nav-item"><a href="/md/designPattern/" class="nav-link">设计模式</a></div><div class="nav-item"><a href="/md/netty/BIO、NIO、AIO.html" class="nav-link">netty</a></div><div class="nav-item"><a href="/md/DDD/小傅哥案例学习打卡/DDD抽奖系统学习打卡🚀 day 1.html" class="nav-link">DDD</a></div><div class="nav-item"><a href="/md/other/面试题.html" class="nav-link">other</a></div><div class="nav-item"><a href="/md/notes/" class="nav-link">测试</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="提示语" class="dropdown-title"><!----> <span class="title" style="display:;">测试下拉菜单</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/md/notes/" class="nav-link">菜单1</a></li><li class="dropdown-item"><!----> <a href="/md/notes/" class="nav-link">菜单2</a></li><li class="dropdown-item"><h4>多次菜单</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/md/notes/" class="nav-link">多级菜单1</a></li></ul></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>消息中间件</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/799774/" aria-current="page" class="active sidebar-link">消息队列</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/799774/#rabbitmq工作模式" class="sidebar-link">RabbitMQ工作模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/799774/#_3-1-简单模式hello-world" class="sidebar-link">3.1 简单模式Hello World</a></li><li class="sidebar-sub-header level3"><a href="/pages/799774/#_3-2-工作队列模式work-queue" class="sidebar-link">3.2 工作队列模式Work Queue</a></li><li class="sidebar-sub-header level3"><a href="/pages/799774/#_3-3-发布-订阅模式publish-subscribe" class="sidebar-link">3.3 发布/订阅模式Publish/Subscribe</a></li><li class="sidebar-sub-header level3"><a href="/pages/799774/#_3-4-路由模式routing" class="sidebar-link">3.4 路由模式Routing</a></li><li class="sidebar-sub-header level3"><a href="/pages/799774/#_3-5-通配符模式topics" class="sidebar-link">3.5 通配符模式Topics</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/799774/#rabbitmq怎么保证执行顺序" class="sidebar-link">RabbitMQ怎么保证执行顺序</a></li><li class="sidebar-sub-header level2"><a href="/pages/799774/#rabbitmq怎么保证消息投递的可靠性" class="sidebar-link">rabbitMQ怎么保证消息投递的可靠性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/799774/#生产者确认" class="sidebar-link">生产者确认</a></li><li class="sidebar-sub-header level3"><a href="/pages/799774/#消费者确认" class="sidebar-link">消费者确认</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/799774/#延迟队列" class="sidebar-link">延迟队列</a></li><li class="sidebar-sub-header level2"><a href="/pages/799774/#如何保证消息可靠性" class="sidebar-link">如何保证消息可靠性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/799774/#_1-消息丢失" class="sidebar-link">1. 消息丢失</a></li><li class="sidebar-sub-header level3"><a href="/pages/799774/#_2-消息重复" class="sidebar-link">2. 消息重复</a></li><li class="sidebar-sub-header level3"><a href="/pages/799774/#_3-消息积压" class="sidebar-link">3. 消息积压</a></li></ul></li></ul></li><li><a href="/pages/3feb62/" class="sidebar-link">RabbitMQ实现延时队列+拓展</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Elasticsearch</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/3c9356/" class="sidebar-link">Elasticsearch</a></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>md</span></li><li data-v-06225672><span data-v-06225672>middleware</span></li><li data-v-06225672><span data-v-06225672>mq</span></li></ul> <div class="info" data-v-06225672><!----> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2022-10-28</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">消息队列<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h1 id="消息队列"><a href="#消息队列" class="header-anchor">#</a> 消息队列</h1> <table><thead><tr><th>特性</th> <th>Kafka</th> <th>RocketMQ</th> <th>ActiveMQ</th> <th>RabbitMQ</th></tr></thead> <tbody><tr><td>吞吐量</td> <td>高吞吐量，可达 10w 级别</td> <td>高吞吐量，可达 10w 级别</td> <td>1w 级别，吞吐量相交比较低</td> <td>1w 级别，吞吐量相交比较低</td></tr> <tr><td>时效性</td> <td>延迟在 ms 级</td> <td>延迟在 ms 级</td> <td>延迟在 ms 级</td> <td>延迟在微妙级，延迟最低</td></tr> <tr><td>可用性</td> <td>天然的分布式系统，数据有副本机制，可用性非常高</td> <td>分布式架构，可用性非常高</td> <td>主从架构，可用性较高</td> <td>同 ActiveMQ</td></tr> <tr><td>维护性</td> <td>基于 Java 和 Scala 语言 实现，社区活跃度高，维护成本较低</td> <td>基于 Java 语言实现，社区活跃度高，维护成本较低</td> <td>基于 Java 语言实现，消息队列场景功能很完备，但社区活跃度较低，维护成本较高</td> <td>基于 erlang 语言开发，社区活跃度一般，小团队维护成本较高</td></tr></tbody></table> <h1 id="rabbitmq"><a href="#rabbitmq" class="header-anchor">#</a> rabbitMQ</h1> <p>作用: 秒杀, 削峰限流, 通信解耦 等等</p> <h2 id="rabbitmq工作模式"><a href="#rabbitmq工作模式" class="header-anchor">#</a> RabbitMQ工作模式</h2> <ol><li>简单模式 一个生产者一个消费者。</li> <li>工作模式 一个生产者多个消费者，与普通模式的区别在于消费者的格式 分发模式分为：轮询分发和公平分发</li> <li>发布订阅模式 一个消费者将消息发送者交换机，交换机同步给绑定的多个队列，然后被监听该队列的消费者消费。</li> <li>路由模式 生产者发送带有路由键的消息给交换机，交换机根据路由键将信息发给绑定的且路由键相同的队列</li> <li>主题模式 与路由模式相比类似于模糊匹配，路由键可以使用通配符</li></ol> <h3 id="_3-1-简单模式hello-world"><a href="#_3-1-简单模式hello-world" class="header-anchor">#</a> 3.1 简单模式Hello World</h3> <p>功能：一个生产者P发送消息到队列Q,一个消费者C接收 生产者实现思路： 创建连接工厂ConnectionFactory，设置服务地址127.0.0.1，端口号5672，设置用户名、密码、virtual host，从连接工厂中获取连接connection，使用连接创建通道channel，使用通道channel创建队列queue，使用通道channel向队列中发送消息，关闭通道和连接。 消费者实现思路 创建连接工厂ConnectionFactory，设置服务地址127.0.0.1，端口号5672，设置用户名、密码、virtual host，从连接工厂中获取连接connection，使用连接创建通道channel，使用通道channel创建队列queue, 创建消费者并监听队列，从队列中读取消息。</p> <h3 id="_3-2-工作队列模式work-queue"><a href="#_3-2-工作队列模式work-queue" class="header-anchor">#</a> 3.2 工作队列模式Work Queue</h3> <p>功能：一个生产者，多个消费者，每个消费者获取到的消息唯一，多个消费者只有一个队列 任务队列：避免立即做一个资源密集型任务，必须等待它完成，而是把这个任务安排到稍后再做。我们将任务封装为消息并将其发送给队列。后台运行的工作进程将弹出任务并最终执行作业。当有多个worker同时运行时，任务将在它们之间共享。 生产者实现思路： 创建连接工厂ConnectionFactory，设置服务地址127.0.0.1，端口号5672，设置用户名、密码、virtual host，从连接工厂中获取连接connection，使用连接创建通道channel，使用通道channel创建队列queue，使用通道channel向队列中发送消息，2条消息之间间隔一定时间，关闭通道和连接。 消费者实现思路： 创建连接工厂ConnectionFactory，设置服务地址127.0.0.1，端口号5672，设置用户名、密码、virtual host，从连接工厂中获取连接connection，使用连接创建通道channel，使用通道channel创建队列queue，创建消费者C1并监听队列，获取消息并暂停10ms，另外一个消费者C2暂停1000ms，由于消费者C1消费速度快，所以C1可以执行更多的任务。</p> <h3 id="_3-3-发布-订阅模式publish-subscribe"><a href="#_3-3-发布-订阅模式publish-subscribe" class="header-anchor">#</a> 3.3 发布/订阅模式Publish/Subscribe</h3> <p>功能：一个生产者发送的消息会被多个消费者获取。一个生产者、一个交换机、多个队列、多个消费者 生产者：可以将消息发送到队列或者是交换机。 消费者：只能从队列中获取消息。 如果消息发送到没有队列绑定的交换机上，那么消息将丢失。 交换机不能存储消息，消息存储在队列中 生产者实现思路： 创建连接工厂ConnectionFactory，设置服务地址127.0.0.1，端口号5672，设置用户名、密码、virtual host，从连接工厂中获取连接connection，使用连接创建通道channel，使用通道channel创建队列queue，使用通道channel创建交换机并指定交换机类型为fanout，使用通道向交换机发送消息，关闭通道和连接。 消费者实现思路： 创建连接工厂ConnectionFactory，设置服务地址127.0.0.1，端口号5672，设置用户名、密码、virtual host，从连接工厂中获取连接connection，使用连接创建通道channel，使用通道channel创建队列queue，绑定队列到交换机，设置Qos=1，创建消费者并监听队列，使用手动方式返回完成。可以有多个队列绑定到交换机，多个消费者进行监听。</p> <h3 id="_3-4-路由模式routing"><a href="#_3-4-路由模式routing" class="header-anchor">#</a> 3.4 路由模式Routing</h3> <p>说明：生产者发送消息到交换机并且要指定路由key，消费者将队列绑定到交换机时需要指定路由key 生产者实现思路： 创建连接工厂ConnectionFactory，设置服务地址127.0.0.1，端口号5672，设置用户名、密码、virtual host，从连接工厂中获取连接connection，使用连接创建通道channel，使用通道channel创建队列queue，使用通道channel创建交换机并指定交换机类型为direct，使用通道向交换机发送消息并指定key=b，关闭通道和连接。 消费者实现思路： 创建连接工厂ConnectionFactory，设置服务地址127.0.0.1，端口号5672，设置用户名、密码、virtual host，从连接工厂中获取连接connection，使用连接创建通道channel，使用通道channel创建队列queue，绑定队列到交换机，设置Qos=1，创建消费者并监听队列，使用手动方式返回完成。可以有多个队列绑定到交换机,但只要绑定key=b的队列key接收到消息，多个消费者进行监听。</p> <h3 id="_3-5-通配符模式topics"><a href="#_3-5-通配符模式topics" class="header-anchor">#</a> 3.5 通配符模式Topics</h3> <p>说明：生产者P发送消息到交换机X，type=topic，交换机根据绑定队列的routi</p> <h2 id="rabbitmq怎么保证执行顺序"><a href="#rabbitmq怎么保证执行顺序" class="header-anchor">#</a> RabbitMQ怎么保证执行顺序</h2> <p>业务操作会有顺序，某个业务新增-&gt;修改-删除，如果顺序乱了就会造成数据不一致性</p> <p>出现顺序错乱主要两种情况: 1.一个队列多个消费者 2.消费者内部进行多线程消费</p> <p>解决方法:(对应上面的问题) 1.使用一个队列一个消费者的模式 2.通过顺序操作的id标识比如订单id, 经过hash取余映射到同一个进程处理</p> <h2 id="rabbitmq怎么保证消息投递的可靠性"><a href="#rabbitmq怎么保证消息投递的可靠性" class="header-anchor">#</a> rabbitMQ怎么保证消息投递的可靠性</h2> <h3 id="生产者确认"><a href="#生产者确认" class="header-anchor">#</a> 生产者确认</h3> <p>生产者通过设置ConfirmCallback回调可以知道,消息是否成功送达服务器, 通过设置ReturnCallback回调, 知道哪些消息投递到队列时失败了, 两个回调,加上本地记录(数据表等等)即可确保生产者的消息投递可靠性</p> <p>配置文件开启回调配置:</p> <div class="language- extra-class"><pre class="language-text"><code>spring:  rabbitmq:    host: 192.168.53.201    port: 5672    username: admin    password: admin    virtual-host: /    #开启发送端确认,到达服务器的确认    publisher-confirm-type: correlated    #开启消息抵达队列确认    publisher-returns: true    #只要抵达队列,以异步模式优先回调returnsConfirm    template:      mandatory: true
</code></pre></div><p>回调设置可以统一写在配置类中</p> <div class="language- extra-class"><pre class="language-text"><code>@PostConstruct  //配置文件对象创建完成以后执行这个方法    public void initRabbitTemplate(){        //设置抵达服务器回调,需要配置文件开启spring.rabbitmq.publisher-confirm-type: correlated        //这是在配置文件统一回调,如果需要单独写 可在每个发送方法上继承RabbitTemplate.ConfirmCallback        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback(){            /**             * @param correlationData  当前消息的唯一关联             * @param ack   是否成功收到             * @param cause   失败原因             */            @Override            public void confirm(CorrelationData correlationData, boolean ack, String cause) {                System.out.println(&quot;回调---&quot;);                if (ack){                    System.out.println(&quot;【配置文件回调确认成功】correlationData：&quot;+correlationData);                }else {                    System.out.println(&quot;【配置文件回调确认失败】correlationData：&quot;+correlationData+&quot;【cause】&quot;+cause);                }            }        });        //抵达队列的确认回调,只要消息没有投递给队列触发失败回调        rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() {            /**             * @param message   投递失败的消息详细信息             * @param replyCode   回复的状态码             * @param replyText   回复的文本内容             * @param exchange     当时发给那个交换机             * @param routingKey    路由键             */            @Override            public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {                System.out.println(&quot;抵达队列失败回调&quot;);            }        });    }
</code></pre></div><h3 id="消费者确认"><a href="#消费者确认" class="header-anchor">#</a> 消费者确认</h3> <p>默认是自动确认的.只要消费端取了数据, 队列就会清楚数据</p> <p>配置文件开启手动ack机制,手动确认下只要没有明确ack,消息就会一直在队列</p> <div class="language- extra-class"><pre class="language-text"><code>spring:  rabbitmq:    #手动ack信息    listener:      simple:        acknowledge-mode: manual
</code></pre></div><p>代码中手动ack消息</p> <div class="language- extra-class"><pre class="language-text"><code>    @RabbitHandler()    public void recvtest (Message message, String hm, Channel c) {        System.out.println(&quot;接收消息:&quot;+message);        byte[] body = message.getBody();        System.out.println(&quot;接收消息体:&quot;+ hm);        try {            if (false){                System.out.println(&quot;签收&quot;);                //手动确认,非批量模式                c.basicAck(message.getMessageProperties().getDeliveryTag(),false);            }else{                System.out.println(&quot;拒收&quot;);                //手动拒绝                //消息的唯一关联   是否批量    是否重新入队,如果否则消息直接丢弃                //long deliveryTag, boolean multiple, boolean requeue                c.basicNack(message.getMessageProperties().getDeliveryTag(),false,true);                //和上面区别就是没有批量                //long deliveryTag, boolean requeue                //c.basicReject();            }        } catch (Exception e) {            //网络中断        }    }
</code></pre></div><h2 id="延迟队列"><a href="#延迟队列" class="header-anchor">#</a> 延迟队列</h2> <p><strong>延迟队列能做什么？</strong></p> <p>延迟队列多用于需要延迟工作的场景。最常见的是以下两种场景：</p> <p>延迟消费。比如：</p> <p>用户生成订单之后，需要过一段时间校验订单的支付状态，如果订单仍未支付则需要及时地关闭订单。</p> <p>用户注册成功之后，需要过一段时间比如一周后校验用户的使用情况，如果发现用户活跃度较低，则发送邮件或者短信来提醒用户使用。</p> <p>延迟重试。比如消费者从队列里消费消息时失败了，但是想要延迟一段时间后自动重试。</p> <p>如果不使用延迟队列，那么我们只能通过一个轮询扫描程序去完成。这种方案既不优雅，也不方便做成统一的服务便于开发人员使用。但是使用延迟队列的话，我们就可以轻而易举地完成。</p> <p><strong>实现思路</strong></p> <p>在介绍具体的实现思路之前，我们先来介绍一下RabbitMQ的两个特性，一个是Time-To-Live Extensions，另一个是Dead Letter Exchanges。</p> <p><strong>Time-To-Live Extensions</strong></p> <p>RabbitMQ允许我们为消息或者队列设置TTL（time to live），也就是过期时间。TTL表明了一条消息可在队列中存活的最大时间，单位为毫秒。也就是说，当某条消息被设置了TTL或者当某条消息进入了设置了TTL的队列时，这条消息会在经过TTL秒后“死亡”，成为Dead Letter。如果既配置了消息的TTL，又配置了队列的TTL，那么较小的那个值会被取用。更多资料请查阅 官方文档 。</p> <p><strong>Dead Letter Exchange</strong></p> <p>刚才提到了，被设置了TTL的消息在过期后会成为Dead Letter。其实在RabbitMQ中，一共有三种消息的“死亡”形式：</p> <p>消息被拒绝。通过调用basic.reject或者basic.nack并且设置的requeue参数为false。</p> <p>消息因为设置了TTL而过期。</p> <p>消息进入了一条已经达到最大长度的队列。</p> <p>如果队列设置了Dead Letter Exchange（DLX），那么这些Dead Letter就会被重新publish到Dead Letter Exchange，通过Dead Letter Exchange路由到其他队列。</p> <p><strong>延迟消费:</strong></p> <p><img src="/img/other/image-ba0deb43fc464c41bbd679f43dfce994.png" alt="/img/other/image-ba0deb43fc464c41bbd679f43dfce994.png"></p> <p>image.png</p> <p><strong>延迟重试:</strong></p> <p><img src="/img/other/image-53cdbf57c5a6460bbd90454a06252097.png" alt="/img/other/image-53cdbf57c5a6460bbd90454a06252097.png"></p> <p>image.png</p> <h2 id="如何保证消息可靠性"><a href="#如何保证消息可靠性" class="header-anchor">#</a> 如何保证消息可靠性</h2> <h3 id="_1-消息丢失"><a href="#_1-消息丢失" class="header-anchor">#</a> 1. 消息丢失</h3> <p><strong>消息发送出去，由于网络问题没有抵达服务器</strong></p> <p>做好容错方法（try-catch），发送消息可能会网络失败，失败后要有重试机制，可记录到数据库，采用定期扫描重发的方式</p> <p>做好日志记录，每个消息状态是否都被服务器收到都应该记录</p> <p>做好定期重发，如果消息没有发送成功，定期去数据库扫描未成功的消息进行重发</p> <p><strong>消息抵达Broker，Broker要将消息写入磁盘（持久化）才算成功。此时Broker尚未持久化完成，宕机</strong></p> <p>publisher也必须加入确认回调机制，确认成功的消息，修改数据库消息状态</p> <p><strong>自动ACK的状态下。消费者收到消息，但没来得及消费然后宕机</strong></p> <p>一定开启手动ack，消费成功才移除，失败或者没来得及处理就noack并重新入队</p> <h3 id="_2-消息重复"><a href="#_2-消息重复" class="header-anchor">#</a> 2. 消息重复</h3> <p><strong>消息消费成功，事务已经提交，ack时，机器宕机。导致没有ack成功，Broker的消息重新由unack变成ready，并发送给其他消费者</strong></p> <p>消费者的业务消费接口应该设计成幂等性的。比如扣库存有工作单的状态标志</p> <p>使用防重表，发送消息每一个都有业务的唯一标识，处理过就不用处理</p> <p>rabbitMQ的每一个消息都有readlivered字段，可以获取是否是被重新投递过来的，而不是第一次投递过来的</p> <p>只要有唯一标识,不论redis还是数据库都可以记录防止重复,或者执行业务修改时,通过某些字段判断该数据已经存在不执行插入或执行更新也可以</p> <h3 id="_3-消息积压"><a href="#_3-消息积压" class="header-anchor">#</a> 3. 消息积压</h3> <p><strong>消费者宕机积压</strong></p> <p><strong>消费者消费能力不足积压</strong></p> <p><strong>发送者发送流量太大</strong></p> <p>上线更多的消费者，进行正常消费</p> <p>上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理</p> <h1 id="rocketmq"><a href="#rocketmq" class="header-anchor">#</a> rocketMQ</h1> <p>pom添加依赖</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;dependency&gt;   &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;   &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;   &lt;version&gt;4.4.0&lt;/version&gt;&lt;/dependency&gt;
</code></pre></div><p>springcloud环境下添加:</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-bus-rocketmq&lt;/artifactId&gt;&lt;/dependency&gt;
</code></pre></div></div></div> <!----> <div class="page-edit"><!----> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><!----> <a href="/pages/3feb62/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">RabbitMQ实现延时队列+拓展</div></a></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/pages/3feb62/">RabbitMQ实现延时队列+拓展</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><!----> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2022-2022
    <span>张大喵</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <div class="body-bg" style="background:url() center center / cover no-repeat;opacity:0.5;"></div> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.9ac200f5.js" defer></script><script src="/assets/js/2.f08c2e94.js" defer></script><script src="/assets/js/50.487406c6.js" defer></script>
  </body>
</html>
