(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{250:function(t,a,e){t.exports=e.p+"assets/img/image-ba0deb43fc464c41bbd679f43dfce994.fa28e7d0.png"},374:function(t,a,e){t.exports=e.p+"assets/img/image-53cdbf57c5a6460bbd90454a06252097.fb052f72.png"},452:function(t,a,e){"use strict";e.r(a);var r=e(3),s=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"消息队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[t._v("#")]),t._v(" 消息队列")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("特性")]),t._v(" "),a("th",[t._v("Kafka")]),t._v(" "),a("th",[t._v("RocketMQ")]),t._v(" "),a("th",[t._v("ActiveMQ")]),t._v(" "),a("th",[t._v("RabbitMQ")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("吞吐量")]),t._v(" "),a("td",[t._v("高吞吐量，可达 10w 级别")]),t._v(" "),a("td",[t._v("高吞吐量，可达 10w 级别")]),t._v(" "),a("td",[t._v("1w 级别，吞吐量相交比较低")]),t._v(" "),a("td",[t._v("1w 级别，吞吐量相交比较低")])]),t._v(" "),a("tr",[a("td",[t._v("时效性")]),t._v(" "),a("td",[t._v("延迟在 ms 级")]),t._v(" "),a("td",[t._v("延迟在 ms 级")]),t._v(" "),a("td",[t._v("延迟在 ms 级")]),t._v(" "),a("td",[t._v("延迟在微妙级，延迟最低")])]),t._v(" "),a("tr",[a("td",[t._v("可用性")]),t._v(" "),a("td",[t._v("天然的分布式系统，数据有副本机制，可用性非常高")]),t._v(" "),a("td",[t._v("分布式架构，可用性非常高")]),t._v(" "),a("td",[t._v("主从架构，可用性较高")]),t._v(" "),a("td",[t._v("同 ActiveMQ")])]),t._v(" "),a("tr",[a("td",[t._v("维护性")]),t._v(" "),a("td",[t._v("基于 Java 和 Scala 语言 实现，社区活跃度高，维护成本较低")]),t._v(" "),a("td",[t._v("基于 Java 语言实现，社区活跃度高，维护成本较低")]),t._v(" "),a("td",[t._v("基于 Java 语言实现，消息队列场景功能很完备，但社区活跃度较低，维护成本较高")]),t._v(" "),a("td",[t._v("基于 erlang 语言开发，社区活跃度一般，小团队维护成本较高")])])])]),t._v(" "),a("h1",{attrs:{id:"rabbitmq"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq"}},[t._v("#")]),t._v(" rabbitMQ")]),t._v(" "),a("p",[t._v("作用: 秒杀, 削峰限流, 通信解耦 等等")]),t._v(" "),a("h2",{attrs:{id:"rabbitmq工作模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq工作模式"}},[t._v("#")]),t._v(" RabbitMQ工作模式")]),t._v(" "),a("ol",[a("li",[t._v("简单模式 一个生产者一个消费者。")]),t._v(" "),a("li",[t._v("工作模式 一个生产者多个消费者，与普通模式的区别在于消费者的格式 分发模式分为：轮询分发和公平分发")]),t._v(" "),a("li",[t._v("发布订阅模式 一个消费者将消息发送者交换机，交换机同步给绑定的多个队列，然后被监听该队列的消费者消费。")]),t._v(" "),a("li",[t._v("路由模式 生产者发送带有路由键的消息给交换机，交换机根据路由键将信息发给绑定的且路由键相同的队列")]),t._v(" "),a("li",[t._v("主题模式 与路由模式相比类似于模糊匹配，路由键可以使用通配符")])]),t._v(" "),a("h3",{attrs:{id:"_3-1-简单模式hello-world"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-简单模式hello-world"}},[t._v("#")]),t._v(" 3.1 简单模式Hello World")]),t._v(" "),a("p",[t._v("功能：一个生产者P发送消息到队列Q,一个消费者C接收 生产者实现思路： 创建连接工厂ConnectionFactory，设置服务地址127.0.0.1，端口号5672，设置用户名、密码、virtual host，从连接工厂中获取连接connection，使用连接创建通道channel，使用通道channel创建队列queue，使用通道channel向队列中发送消息，关闭通道和连接。 消费者实现思路 创建连接工厂ConnectionFactory，设置服务地址127.0.0.1，端口号5672，设置用户名、密码、virtual host，从连接工厂中获取连接connection，使用连接创建通道channel，使用通道channel创建队列queue, 创建消费者并监听队列，从队列中读取消息。")]),t._v(" "),a("h3",{attrs:{id:"_3-2-工作队列模式work-queue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-工作队列模式work-queue"}},[t._v("#")]),t._v(" 3.2 工作队列模式Work Queue")]),t._v(" "),a("p",[t._v("功能：一个生产者，多个消费者，每个消费者获取到的消息唯一，多个消费者只有一个队列 任务队列：避免立即做一个资源密集型任务，必须等待它完成，而是把这个任务安排到稍后再做。我们将任务封装为消息并将其发送给队列。后台运行的工作进程将弹出任务并最终执行作业。当有多个worker同时运行时，任务将在它们之间共享。 生产者实现思路： 创建连接工厂ConnectionFactory，设置服务地址127.0.0.1，端口号5672，设置用户名、密码、virtual host，从连接工厂中获取连接connection，使用连接创建通道channel，使用通道channel创建队列queue，使用通道channel向队列中发送消息，2条消息之间间隔一定时间，关闭通道和连接。 消费者实现思路： 创建连接工厂ConnectionFactory，设置服务地址127.0.0.1，端口号5672，设置用户名、密码、virtual host，从连接工厂中获取连接connection，使用连接创建通道channel，使用通道channel创建队列queue，创建消费者C1并监听队列，获取消息并暂停10ms，另外一个消费者C2暂停1000ms，由于消费者C1消费速度快，所以C1可以执行更多的任务。")]),t._v(" "),a("h3",{attrs:{id:"_3-3-发布-订阅模式publish-subscribe"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-发布-订阅模式publish-subscribe"}},[t._v("#")]),t._v(" 3.3 发布/订阅模式Publish/Subscribe")]),t._v(" "),a("p",[t._v("功能：一个生产者发送的消息会被多个消费者获取。一个生产者、一个交换机、多个队列、多个消费者 生产者：可以将消息发送到队列或者是交换机。 消费者：只能从队列中获取消息。 如果消息发送到没有队列绑定的交换机上，那么消息将丢失。 交换机不能存储消息，消息存储在队列中 生产者实现思路： 创建连接工厂ConnectionFactory，设置服务地址127.0.0.1，端口号5672，设置用户名、密码、virtual host，从连接工厂中获取连接connection，使用连接创建通道channel，使用通道channel创建队列queue，使用通道channel创建交换机并指定交换机类型为fanout，使用通道向交换机发送消息，关闭通道和连接。 消费者实现思路： 创建连接工厂ConnectionFactory，设置服务地址127.0.0.1，端口号5672，设置用户名、密码、virtual host，从连接工厂中获取连接connection，使用连接创建通道channel，使用通道channel创建队列queue，绑定队列到交换机，设置Qos=1，创建消费者并监听队列，使用手动方式返回完成。可以有多个队列绑定到交换机，多个消费者进行监听。")]),t._v(" "),a("h3",{attrs:{id:"_3-4-路由模式routing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-路由模式routing"}},[t._v("#")]),t._v(" 3.4 路由模式Routing")]),t._v(" "),a("p",[t._v("说明：生产者发送消息到交换机并且要指定路由key，消费者将队列绑定到交换机时需要指定路由key 生产者实现思路： 创建连接工厂ConnectionFactory，设置服务地址127.0.0.1，端口号5672，设置用户名、密码、virtual host，从连接工厂中获取连接connection，使用连接创建通道channel，使用通道channel创建队列queue，使用通道channel创建交换机并指定交换机类型为direct，使用通道向交换机发送消息并指定key=b，关闭通道和连接。 消费者实现思路： 创建连接工厂ConnectionFactory，设置服务地址127.0.0.1，端口号5672，设置用户名、密码、virtual host，从连接工厂中获取连接connection，使用连接创建通道channel，使用通道channel创建队列queue，绑定队列到交换机，设置Qos=1，创建消费者并监听队列，使用手动方式返回完成。可以有多个队列绑定到交换机,但只要绑定key=b的队列key接收到消息，多个消费者进行监听。")]),t._v(" "),a("h3",{attrs:{id:"_3-5-通配符模式topics"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-通配符模式topics"}},[t._v("#")]),t._v(" 3.5 通配符模式Topics")]),t._v(" "),a("p",[t._v("说明：生产者P发送消息到交换机X，type=topic，交换机根据绑定队列的routi")]),t._v(" "),a("h2",{attrs:{id:"rabbitmq怎么保证执行顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq怎么保证执行顺序"}},[t._v("#")]),t._v(" RabbitMQ怎么保证执行顺序")]),t._v(" "),a("p",[t._v("业务操作会有顺序，某个业务新增->修改-删除，如果顺序乱了就会造成数据不一致性")]),t._v(" "),a("p",[t._v("出现顺序错乱主要两种情况: 1.一个队列多个消费者 2.消费者内部进行多线程消费")]),t._v(" "),a("p",[t._v("解决方法:(对应上面的问题) 1.使用一个队列一个消费者的模式 2.通过顺序操作的id标识比如订单id, 经过hash取余映射到同一个进程处理")]),t._v(" "),a("h2",{attrs:{id:"rabbitmq怎么保证消息投递的可靠性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq怎么保证消息投递的可靠性"}},[t._v("#")]),t._v(" rabbitMQ怎么保证消息投递的可靠性")]),t._v(" "),a("h3",{attrs:{id:"生产者确认"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生产者确认"}},[t._v("#")]),t._v(" 生产者确认")]),t._v(" "),a("p",[t._v("生产者通过设置ConfirmCallback回调可以知道,消息是否成功送达服务器, 通过设置ReturnCallback回调, 知道哪些消息投递到队列时失败了, 两个回调,加上本地记录(数据表等等)即可确保生产者的消息投递可靠性")]),t._v(" "),a("p",[t._v("配置文件开启回调配置:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("spring:  rabbitmq:    host: 192.168.53.201    port: 5672    username: admin    password: admin    virtual-host: /    #开启发送端确认,到达服务器的确认    publisher-confirm-type: correlated    #开启消息抵达队列确认    publisher-returns: true    #只要抵达队列,以异步模式优先回调returnsConfirm    template:      mandatory: true\n")])])]),a("p",[t._v("回调设置可以统一写在配置类中")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('@PostConstruct  //配置文件对象创建完成以后执行这个方法    public void initRabbitTemplate(){        //设置抵达服务器回调,需要配置文件开启spring.rabbitmq.publisher-confirm-type: correlated        //这是在配置文件统一回调,如果需要单独写 可在每个发送方法上继承RabbitTemplate.ConfirmCallback        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback(){            /**             * @param correlationData  当前消息的唯一关联             * @param ack   是否成功收到             * @param cause   失败原因             */            @Override            public void confirm(CorrelationData correlationData, boolean ack, String cause) {                System.out.println("回调---");                if (ack){                    System.out.println("【配置文件回调确认成功】correlationData："+correlationData);                }else {                    System.out.println("【配置文件回调确认失败】correlationData："+correlationData+"【cause】"+cause);                }            }        });        //抵达队列的确认回调,只要消息没有投递给队列触发失败回调        rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() {            /**             * @param message   投递失败的消息详细信息             * @param replyCode   回复的状态码             * @param replyText   回复的文本内容             * @param exchange     当时发给那个交换机             * @param routingKey    路由键             */            @Override            public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {                System.out.println("抵达队列失败回调");            }        });    }\n')])])]),a("h3",{attrs:{id:"消费者确认"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消费者确认"}},[t._v("#")]),t._v(" 消费者确认")]),t._v(" "),a("p",[t._v("默认是自动确认的.只要消费端取了数据, 队列就会清楚数据")]),t._v(" "),a("p",[t._v("配置文件开启手动ack机制,手动确认下只要没有明确ack,消息就会一直在队列")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("spring:  rabbitmq:    #手动ack信息    listener:      simple:        acknowledge-mode: manual\n")])])]),a("p",[t._v("代码中手动ack消息")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('    @RabbitHandler()    public void recvtest (Message message, String hm, Channel c) {        System.out.println("接收消息:"+message);        byte[] body = message.getBody();        System.out.println("接收消息体:"+ hm);        try {            if (false){                System.out.println("签收");                //手动确认,非批量模式                c.basicAck(message.getMessageProperties().getDeliveryTag(),false);            }else{                System.out.println("拒收");                //手动拒绝                //消息的唯一关联   是否批量    是否重新入队,如果否则消息直接丢弃                //long deliveryTag, boolean multiple, boolean requeue                c.basicNack(message.getMessageProperties().getDeliveryTag(),false,true);                //和上面区别就是没有批量                //long deliveryTag, boolean requeue                //c.basicReject();            }        } catch (Exception e) {            //网络中断        }    }\n')])])]),a("h2",{attrs:{id:"延迟队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#延迟队列"}},[t._v("#")]),t._v(" 延迟队列")]),t._v(" "),a("p",[a("strong",[t._v("延迟队列能做什么？")])]),t._v(" "),a("p",[t._v("延迟队列多用于需要延迟工作的场景。最常见的是以下两种场景：")]),t._v(" "),a("p",[t._v("延迟消费。比如：")]),t._v(" "),a("p",[t._v("用户生成订单之后，需要过一段时间校验订单的支付状态，如果订单仍未支付则需要及时地关闭订单。")]),t._v(" "),a("p",[t._v("用户注册成功之后，需要过一段时间比如一周后校验用户的使用情况，如果发现用户活跃度较低，则发送邮件或者短信来提醒用户使用。")]),t._v(" "),a("p",[t._v("延迟重试。比如消费者从队列里消费消息时失败了，但是想要延迟一段时间后自动重试。")]),t._v(" "),a("p",[t._v("如果不使用延迟队列，那么我们只能通过一个轮询扫描程序去完成。这种方案既不优雅，也不方便做成统一的服务便于开发人员使用。但是使用延迟队列的话，我们就可以轻而易举地完成。")]),t._v(" "),a("p",[a("strong",[t._v("实现思路")])]),t._v(" "),a("p",[t._v("在介绍具体的实现思路之前，我们先来介绍一下RabbitMQ的两个特性，一个是Time-To-Live Extensions，另一个是Dead Letter Exchanges。")]),t._v(" "),a("p",[a("strong",[t._v("Time-To-Live Extensions")])]),t._v(" "),a("p",[t._v("RabbitMQ允许我们为消息或者队列设置TTL（time to live），也就是过期时间。TTL表明了一条消息可在队列中存活的最大时间，单位为毫秒。也就是说，当某条消息被设置了TTL或者当某条消息进入了设置了TTL的队列时，这条消息会在经过TTL秒后“死亡”，成为Dead Letter。如果既配置了消息的TTL，又配置了队列的TTL，那么较小的那个值会被取用。更多资料请查阅 官方文档 。")]),t._v(" "),a("p",[a("strong",[t._v("Dead Letter Exchange")])]),t._v(" "),a("p",[t._v("刚才提到了，被设置了TTL的消息在过期后会成为Dead Letter。其实在RabbitMQ中，一共有三种消息的“死亡”形式：")]),t._v(" "),a("p",[t._v("消息被拒绝。通过调用basic.reject或者basic.nack并且设置的requeue参数为false。")]),t._v(" "),a("p",[t._v("消息因为设置了TTL而过期。")]),t._v(" "),a("p",[t._v("消息进入了一条已经达到最大长度的队列。")]),t._v(" "),a("p",[t._v("如果队列设置了Dead Letter Exchange（DLX），那么这些Dead Letter就会被重新publish到Dead Letter Exchange，通过Dead Letter Exchange路由到其他队列。")]),t._v(" "),a("p",[a("strong",[t._v("延迟消费:")])]),t._v(" "),a("p",[a("img",{attrs:{src:e(250),alt:"../../../img//other/image-ba0deb43fc464c41bbd679f43dfce994.png"}})]),t._v(" "),a("p",[t._v("image.png")]),t._v(" "),a("p",[a("strong",[t._v("延迟重试:")])]),t._v(" "),a("p",[a("img",{attrs:{src:e(374),alt:"../../../img//other/image-53cdbf57c5a6460bbd90454a06252097.png"}})]),t._v(" "),a("p",[t._v("image.png")]),t._v(" "),a("h2",{attrs:{id:"如何保证消息可靠性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何保证消息可靠性"}},[t._v("#")]),t._v(" 如何保证消息可靠性")]),t._v(" "),a("h3",{attrs:{id:"_1-消息丢失"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-消息丢失"}},[t._v("#")]),t._v(" 1. 消息丢失")]),t._v(" "),a("p",[a("strong",[t._v("消息发送出去，由于网络问题没有抵达服务器")])]),t._v(" "),a("p",[t._v("做好容错方法（try-catch），发送消息可能会网络失败，失败后要有重试机制，可记录到数据库，采用定期扫描重发的方式")]),t._v(" "),a("p",[t._v("做好日志记录，每个消息状态是否都被服务器收到都应该记录")]),t._v(" "),a("p",[t._v("做好定期重发，如果消息没有发送成功，定期去数据库扫描未成功的消息进行重发")]),t._v(" "),a("p",[a("strong",[t._v("消息抵达Broker，Broker要将消息写入磁盘（持久化）才算成功。此时Broker尚未持久化完成，宕机")])]),t._v(" "),a("p",[t._v("publisher也必须加入确认回调机制，确认成功的消息，修改数据库消息状态")]),t._v(" "),a("p",[a("strong",[t._v("自动ACK的状态下。消费者收到消息，但没来得及消费然后宕机")])]),t._v(" "),a("p",[t._v("一定开启手动ack，消费成功才移除，失败或者没来得及处理就noack并重新入队")]),t._v(" "),a("h3",{attrs:{id:"_2-消息重复"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-消息重复"}},[t._v("#")]),t._v(" 2. 消息重复")]),t._v(" "),a("p",[a("strong",[t._v("消息消费成功，事务已经提交，ack时，机器宕机。导致没有ack成功，Broker的消息重新由unack变成ready，并发送给其他消费者")])]),t._v(" "),a("p",[t._v("消费者的业务消费接口应该设计成幂等性的。比如扣库存有工作单的状态标志")]),t._v(" "),a("p",[t._v("使用防重表，发送消息每一个都有业务的唯一标识，处理过就不用处理")]),t._v(" "),a("p",[t._v("rabbitMQ的每一个消息都有readlivered字段，可以获取是否是被重新投递过来的，而不是第一次投递过来的")]),t._v(" "),a("p",[t._v("只要有唯一标识,不论redis还是数据库都可以记录防止重复,或者执行业务修改时,通过某些字段判断该数据已经存在不执行插入或执行更新也可以")]),t._v(" "),a("h3",{attrs:{id:"_3-消息积压"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-消息积压"}},[t._v("#")]),t._v(" 3. 消息积压")]),t._v(" "),a("p",[a("strong",[t._v("消费者宕机积压")])]),t._v(" "),a("p",[a("strong",[t._v("消费者消费能力不足积压")])]),t._v(" "),a("p",[a("strong",[t._v("发送者发送流量太大")])]),t._v(" "),a("p",[t._v("上线更多的消费者，进行正常消费")]),t._v(" "),a("p",[t._v("上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理")]),t._v(" "),a("h1",{attrs:{id:"rocketmq"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq"}},[t._v("#")]),t._v(" rocketMQ")]),t._v(" "),a("p",[t._v("pom添加依赖")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<dependency>   <groupId>org.apache.rocketmq</groupId>   <artifactId>rocketmq-client</artifactId>   <version>4.4.0</version></dependency>\n")])])]),a("p",[t._v("springcloud环境下添加:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<dependency>    <groupId>com.alibaba.cloud</groupId>    <artifactId>spring-cloud-starter-bus-rocketmq</artifactId></dependency>\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);