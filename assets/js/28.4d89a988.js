(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{342:function(t,r,s){"use strict";s.r(r);var a=s(3),e=Object(a.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"装饰模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#装饰模式"}},[t._v("#")]),t._v(" 装饰模式")]),t._v(" "),r("h3",{attrs:{id:"定义"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),r("p",[t._v("装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。")]),t._v(" "),r("p",[t._v("这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。")]),t._v(" "),r("p",[t._v("在不改变一个类的情况下,拓展一个类, 可以使用继承, 但是如果这个类是多个实现子类的情况呢? 装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。")]),t._v(" "),r("h3",{attrs:{id:"实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),r("p",[t._v("装饰模式是用一个"),r("strong",[t._v("抽象")]),t._v("父类实现目标接口, 构造函数需要传入目标接口的实现类, 抽象类重写所有方法默认调用传入实现类的方法,然后其子类重写"),r("strong",[t._v("需要增强的方法")]),t._v(", 这样就可以通过调用方传入的目标接口的实现类调用到原方法, 实现附加操作统一")]),t._v(" "),r("p",[r("img",{attrs:{src:"/img/other/test.png",alt:"/img/other/test.png"}})])])}),[],!1,null,null,null);r.default=e.exports}}]);