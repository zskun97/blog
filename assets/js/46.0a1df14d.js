(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{423:function(r,e,a){"use strict";a.r(e);var s=a(3),t=Object(s.a)({},(function(){var r=this,e=r._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h1",{attrs:{id:"建造者模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#建造者模式"}},[r._v("#")]),r._v(" 建造者模式")]),r._v(" "),e("h3",{attrs:{id:"定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[r._v("#")]),r._v(" 定义")]),r._v(" "),e("p",[r._v("建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。")]),r._v(" "),e("p",[r._v("一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。")]),r._v(" "),e("p",[r._v("**意图：**将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。")]),r._v(" "),e("p",[r._v("**主要解决：**主要解决在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。")]),r._v(" "),e("p",[r._v("**何时使用：**一些基本部件不会变，而其组合经常变化的时候。")]),r._v(" "),e("p",[r._v("**使用案例：**JAVA 中的 StringBuilder ； org.springframework.amqp.core.BindingBuilder 绑定交换机和队列")]),r._v(" "),e("p",[r._v("该模式"),e("strong",[r._v("注重于对象的构建过程，用来构建复杂的对象，同时根据情况还区分是否需要与用户交互")])]),r._v(" "),e("p",[e("strong",[r._v("不交互")]),r._v("：快餐店又不同的套餐，套餐内不同的餐品都是不同的对象，我们可以在builder中提供该套餐的获取方法，直接将构建好的嵌套对象返回；")]),r._v(" "),e("p",[e("strong",[r._v("交互")]),r._v("：以org.springframework.amqp.core.BindingBuilder举例，过程中需要用户传入我们需要的信息，是将变化的部分交给调用者决定,并且通过每一步返回对象的不同也可以控制用户下一步的动作； StringBuilder也需要我们传入数据,最后返回拼接好的字符串;")]),r._v(" "),e("h3",{attrs:{id:"实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[r._v("#")]),r._v(" 实现")]),r._v(" "),e("p",[e("strong",[r._v("定义零食和汉堡")]),r._v(", 这里偷懒没有接口抽象")]),r._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[r._v("/** * 这里偷懒没有写成接口,而是通过name不同表示不同对象 */@Data@AllArgsConstructorpublic class Hamburger {    String name;}\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[r._v("/** * 这里偷懒没有写成接口,而是通过name不同表示不同对象 */@Data@AllArgsConstructorpublic class Snacks {    String name;}\n")])])]),e("p",[e("strong",[r._v("定义套餐订单")])]),r._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[r._v('@Data@Builder@NoArgsConstructor@AllArgsConstructorpublic class Order {    Hamburger hamburger;    Snacks snacks;    public void orderInfo(){        System.out.println("汉堡:"+hamburger.name+"  零食:"+snacks.name);    }}\n')])])]),e("p",[e("strong",[r._v("建造器(交互/不交互的方法都有)")])]),r._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[r._v('@Componentpublic class OrderBuilder {    /**     * 获取套餐A,不交互     */    public Order getPackageA(){        //这个实现通过普通new和set操作        Order order = new Order();        //order需要通过其他对象构建        order.setHamburger(new Hamburger("汉堡A"));        order.setSnacks(new Snacks("零食A"));        //用户调用这个方法直接返回组建好的订单        return order;    }    /**     * 获取套餐B,不交互     */    public Order getPackageB(){        //这个方法通过lombak提供的builder注解, 这个注解就是给这个对象提供了个生成器,用于创建对象时链式的传入参数,每一步返回的是生成器自身        //这是个交互式, 因为需要参与动态部分        Order order = Order.builder().snacks(new Snacks("零食B")).hamburger(new Hamburger("汉堡B")).build();        return order;    }    /**     * 这里我们自己写个仿lombak的builder生成器,这是一个特别简单的就是构建时循环传参的,     * 实际不用自己写有注解可用,但是这种思路下可以自己定义很多东西, 比如第一步只能设置汉堡,或者build时校验某些参数不能为空     * @return     */    public static Builder builder(){        return new Builder();    }    /**     * 生成器     */    public static class Builder {        Hamburger hamburger;        Snacks Snacks;        public Builder setHamburger(Hamburger hamburger){            this.hamburger=hamburger;            return this;        }        public Builder setSnacks(Snacks snacks){            this.Snacks = snacks;            return this;        }        public Order build(){            Order order = new Order(hamburger, Snacks);            return order;        }    }}\n')])])]),e("p",[e("strong",[r._v("测试调用")])]),r._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[r._v('@ResourceOrderBuilder orderBuilder;@Testvoid main(){    //获取套餐A    Order packageA = orderBuilder.getPackageA();    packageA.orderInfo();    //获取套餐B    Order packageB = orderBuilder.getPackageB();    packageB.orderInfo();    //试试自己写的生成器    Order order = OrderBuilder.builder()            .setHamburger(new Hamburger("自定义汉堡"))            .setSnacks(new Snacks("自定义零食"))            .build();    order.orderInfo();}\n')])])]),e("p",[e("strong",[r._v("结果")])]),r._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[r._v("汉堡:汉堡A  零食:零食A\n汉堡:汉堡B  零食:零食B\n汉堡:自定义汉堡  零食:自定义零食\n")])])]),e("h3",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[r._v("#")]),r._v(" 总结")]),r._v(" "),e("p",[r._v("主要用于构建负责对象, 重点正在构建过程")]),r._v(" "),e("p",[r._v("根据情况可以分交互或不交互, 交互的就是将动态的部分交给调用者决定, 不交互就是预设复杂对象的模板")]),r._v(" "),e("p",[e("strong",[r._v("思考")]),r._v(": 通过builder构建对象和通过有参构造构造有啥区别呢？ 首先这两个通用的场景是需要交互的, 也就是需要调用者提供信息 如果只有几个参数,并且不要求顺序,两者没有太大区别, 只是将new的步骤放到了builder中. builder构建可以链式调用并且明确看出传入这个参数赋给了谁, 而有参构造需要注意参数顺序,比如(a,b,c)和(a,c,b)还是有区别的;")])])}),[],!1,null,null,null);e.default=t.exports}}]);