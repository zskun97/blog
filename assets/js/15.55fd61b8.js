(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{328:function(e,_,v){"use strict";v.r(_);var o=v(3),r=Object(o.a)({},(function(){var e=this,_=e._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引"}},[e._v("#")]),e._v(" 索引")]),e._v(" "),_("p",[_("strong",[e._v("索引是一种特殊的数据库结构，由数据表中的一列或多列组合而成，可以用来快速查询数据表中有某一特定值的记录。")])]),e._v(" "),_("p",[e._v("优点：")]),e._v(" "),_("ol",[_("li",[e._v("大大加快查询速度。")])]),e._v(" "),_("p",[e._v("缺点：")]),e._v(" "),_("ol",[_("li",[e._v("维护索引需要消费数据库资源。")]),e._v(" "),_("li",[e._v("索引需要占用磁盘空间。")]),e._v(" "),_("li",[e._v("当对表的数据进行增删改的时候，因为要维护索引，所以速度会受到影响。")])]),e._v(" "),_("p",[e._v("如果现在有一条 SQL 语句：")]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from user where id = 40")])])]),e._v(" "),_("p",[e._v("如果没有索引的条件下，我们要找到这条记录，我们就需要在数据中进行全表扫描，匹配 id = 40 的数据。")]),e._v(" "),_("p",[e._v("如果有了索引，我们就可以通过索引进行快速查找，可以先在索引中通过 id = 40 进行二分查找，再根据定位到的地址取出对应的行数据。")]),e._v(" "),_("p",[_("strong",[e._v("11.1.1 索引类型")])]),e._v(" "),_("ul",[_("li",[e._v("主键索引：数据列不允许重复，不允许为 NULL，一个表只能有一个主键，设置主键后数据库会自动创建索引。")]),e._v(" "),_("li",[e._v("唯一索引：数据列不允许重复，允许为 NULL 值，一个表允许多个列创建唯一索引。")])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("// 创建唯一索引")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("ALTER TABLE table_name ADD UNIQUE (column);")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("// 创建唯一组合索引")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2);")])])]),e._v(" "),_("ul",[_("li",[e._v("普通索引：基本的索引类型，没有唯一性的限制，允许为 NULL 值。")])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("// 创建普通索引")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("ALTER TABLE table_name ADD INDEX index_name (column);")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("// 创建组合索引")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);")])])]),e._v(" "),_("ul",[_("li",[e._v("复合索引：一个索引包含多个列。")])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("ALTER TABLE table_name ADD INDEX index_name (column1,column2, column3);")])])]),e._v(" "),_("ul",[_("li",[e._v("全文索引： 是目前搜索引擎使用的一种关键技术。允许重复值和 NULL 值，只在 TEXT 数据类型上创建**（仅 MyISAM 引擎支持全文索引）。**")])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("// 创建全文索引")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("ALTER TABLE table_name ADD FULLTEXT (column);")])])]),e._v(" "),_("p",[_("strong",[e._v("11.1.2 最左匹配原则")])]),e._v(" "),_("p",[e._v("最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询（>、<、between、like）就会停止匹配。")]),e._v(" "),_("p",[e._v("多列索引是先按照第一列进行排序，然后在第一列排好序的基础上再对第二列排序，如果没有第一列的话，直接访问第二列，那第二列肯定是无序的，直接访问后面的列就用不到索引了。")]),e._v(" "),_("p",[e._v("举例：创建一个（a,b）的联合索引，那么它的索引树就是下图的样子。")]),e._v(" "),_("p",[e._v("可以看到 a 的值是有顺序的，1，1，2，2，3，3，而 b 的值是没有顺序的1，2，1，4，1，2。但是我们又可发现 a 在等值的情况下，b 值又是按顺序排列的，但是这种顺序是相对的。这是因为 MySQL 创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以 b=2 这种查询条件没有办法利用索引。")]),e._v(" "),_("p",[_("strong",[e._v("1、全值匹配查询时")])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name where a = '1' and b = '2' and c = '3'")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name where b = '2' and a = '1' and c = '3'")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name where c = '3' and b = '2' and a = '1'")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("......")])])]),e._v(" "),_("p",[e._v("SQL 语句用到了索引，where 子句几个搜索条件顺序调换不影响查询结果，因为 MySQL 中有查询优化器，会自动优化查询顺序 。")]),e._v(" "),_("p",[_("strong",[e._v("2、匹配左边的列时")])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name where a = '1'")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name where a = '1' and b = '2'")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name where a = '1' and b = '2' and c = '3'")])])]),e._v(" "),_("p",[e._v("SQL 语句都从最左边开始连续匹配，用到了索引。")]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name where b = '2'")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name where c = '3'")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name where b = '1' and c = '3'")])])]),e._v(" "),_("p",[e._v("这些没有从最左边开始，最后查询没有用到索引，用的是全表扫描 。")]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name where a = '1' and c = '3'")])])]),e._v(" "),_("p",[e._v("如果不连续时，只用到了 a 列的索引，b 列和 c 列都没有用到 。")]),e._v(" "),_("p",[_("strong",[e._v("3、匹配列前缀")])]),e._v(" "),_("p",[e._v("如果列是字符型的话它的比较规则是先比较字符串的第一个字符，第一个字符小的哪个字符串就比较小，如果两个字符串第一个字符相通，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小，依次类推，比较字符串。")]),e._v(" "),_("p",[e._v("如果 a 是字符类型，那么前缀匹配用的是索引，后缀和中缀只能全表扫描了。")]),e._v(" "),_("p",[_("strong",[_("code",[e._v("// 前缀都是排好序的，走索引查询")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name where a like 'As%';")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("// 全表查询")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name where a like '%As'")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("// 全表查询")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name where a like '%As%'")])])]),e._v(" "),_("p",[_("strong",[e._v("4、匹配范围值")])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name where a > 1 and a < 3")])])]),e._v(" "),_("p",[e._v("可以对最左边的列进行范围查询。")]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name where a > 1 and a < 3 and b > 1;")])])]),e._v(" "),_("p",[e._v("多个列同时进行范围查找时，只有对索引最左边的那个列进行范围查找才用到 B+Tree 索引，也就是只有 a 用到索引，在 1<a<3 的范围内 b 是无序的，不能用索引，找到 1<a<3 的记录后，只能根据条件 b > 1继续逐条过滤。")]),e._v(" "),_("p",[_("strong",[e._v("5、精确匹配某一列并范围匹配另外一列")])]),e._v(" "),_("p",[e._v("如果左边的列是精确查找的，右边的列可以进行范围查找。")]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name where a = 1 and b > 3;")])])]),e._v(" "),_("p",[e._v("a=1 的情况下 b 是有序的，进行范围查找走的是联合索引。")]),e._v(" "),_("p",[_("strong",[e._v("6、排序")])]),e._v(" "),_("p",[e._v("一般情况下，我们只能把记录加载到内存中，再用一些排序算法，比如快速排序，归并排序等在内存中对这些记录进行排序，有时候查询的结果集太大不能在内存中进行排序的话，还可能暂时借助磁盘空间存放中间结果，排序操作完成后再把排好序的结果返回客户端。MySQL 中把这种再内存中或磁盘上进行排序的方式统称为文件排序。文件排序非常慢，但如果 ORDER 子句用到了索引列，就有可能省去文件排序的步骤。")]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name order by a,b,c limit 10;")])])]),e._v(" "),_("p",[e._v("因为 B+Tree 索引本身就是按照上述规则排序的，所以可以直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好了。")]),e._v(" "),_("p",[e._v("ORDER BY 的子句后面的顺序也必须按照索引列的顺序给出，比如：")]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name order by b,c,a limit 10;")])])]),e._v(" "),_("p",[e._v("上述这种颠倒顺序的没有用到索引。")]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name order by a limit 10;")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name order by a,b limit 10;")])])]),e._v(" "),_("p",[e._v("上述这种用到部分索引。")]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from table_name where a =1 order by b,c limit 10;")])])]),e._v(" "),_("p",[e._v("联合索引左边列为常量，后边的列排序可以用到索引。")]),e._v(" "),_("p",[_("strong",[e._v("11.1.3 索引的数据结构")])]),e._v(" "),_("p",[e._v("索引的数据结构和具体存储引擎的实现有关，在 MySQL 中使用较多的索引有 Hash 索引，B+Tree 索引等。MyISAM 和 InnoDB 存储引擎支持 B-Tree索引；memory/heap 存储引擎可以支持 Hash 和 B-Tree 索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择 B-Tree 索引。")]),e._v(" "),_("p",[_("strong",[e._v("B-Tree 索引")])]),e._v(" "),_("p",[e._v("MySQL 通过存储引擎取数据，基本上 90% 的人用的就是 InnoDB 了，按照实现方式分，InnoDB 的索引类型目前只有两种：B-Tree（B树）索引和 HASH 索引。B-TREE 索引是 MySQL 数据库中使用最频繁的索引类型，基本所有存储引擎都支持 B-Tree 索引。通常我们说的索引不出意外指的就是B-Tree 索引（实际是用 B+Tree 实现的，因为在查看表索引时，MySQL 一律打印 B-Tree，所以简称为 B-Tree 索引）。")]),e._v(" "),_("p",[_("strong",[e._v("（1）B-Tree")])]),e._v(" "),_("p",[e._v("B-Tree 是一个绝对平衡树，所有的叶子节点在同一高度，如下图所示：、")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/E75A719B2E844191B94FC7405D1E1E1F/10985",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/E75A719B2E844191B94FC7405D1E1E1F/10985"),_("OutboundLink")],1)]),e._v(" "),_("p",[e._v("上图为一个 2- 3树（每个节点存储 2 个关键字，有 3 路），多路平衡查找树也就是多叉的意思，从上图中可以看出，每个节点保存的关键字的个数和路数关系为：关键字个数 = 路数 – 1。")]),e._v(" "),_("p",[e._v("假设要从上图中查找id = X 的数据，B TREE 搜索过程如下：")]),e._v(" "),_("ol",[_("li",[e._v("取出根磁盘块，加载 40 和 60 两个关键字。")]),e._v(" "),_("li",[e._v("如果 X 等于 40，则命中；如果 X 小于 40 走 P1；如果 40 < X < 60 走 P2；如果 X = 60，则命中；如果 X > 60 走 P3。")]),e._v(" "),_("li",[e._v("根据以上规则命中后，接下来加载对应的数据， 数据区中存储的是具体的数据或者是指向数据的指针。")])]),e._v(" "),_("p",[e._v("B Tree 能够很好的利用操作系统和磁盘的交互特性， "),_("strong",[e._v("MySQL 为了很好的利用磁盘的预读能力，将页大小设置为 16K，即将一个节点（磁盘块）的大小设置为 16K，一次 IO 将一个节点（16K）内容加载进内存")]),e._v("。这里，假设关键字类型为 int，即 4 字节，若每个关键字对应的数据区也为 4 字节，不考虑子节点引用的情况下，则上图中的每个节点大约能够存储（16 * 1000）/ 8 = 2000 个关键字，共 2001 个路数。对于二叉树，三层高度，最多可以保存 7 个关键字，而对于这种有 2001 路的 B 树，"),_("strong",[e._v("三层高度能够搜索的关键字个数远远的大于二叉树")]),e._v("。")]),e._v(" "),_("p",[e._v("在B Tree保证树的平衡的过程中，每次关键字的变化，都会导致结构发生很大的变化，这个过程是特别浪费时间的，所以创建索引一定要创建合适的索引，而不是把所有的字段都创建索引，创建冗余索引只会在对数据进行新增，删除，修改时增加性能消耗。")]),e._v(" "),_("p",[_("strong",[e._v("（2）B+Tree")])]),e._v(" "),_("p",[e._v("B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 引擎就是用B+Tree 实现其索引结构。、")]),e._v(" "),_("p",[e._v("在 B+Tree 中，B树 的路数和关键字的个数的关系不再成立了，数据检索规则采用的是左闭右合区间，路数和关键个数关系为 1 比 1，具体如下图所示：")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/361D75777D554019AE4D94AE641D073A/11028",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/361D75777D554019AE4D94AE641D073A/11028"),_("OutboundLink")],1)]),e._v(" "),_("p",[e._v("如果上图中是用 ID 做的索引，如果是搜索 X = 1 的数据，搜索规则如下：")]),e._v(" "),_("ol",[_("li",[e._v("取出根磁盘块，加载 1，28，66 三个关键字。")]),e._v(" "),_("li",[e._v("X <= 1 走 P1，取出磁盘块，加载 1，10，20 三个关键字。")]),e._v(" "),_("li",[e._v("X <= 1 走 P1，取出磁盘块，加载 1，8，9 三个关键字。")]),e._v(" "),_("li",[e._v("已经到达叶子节点，命中 1，接下来加载对应的数据，图中数据区中存储的是具体的数据。")])]),e._v(" "),_("p",[_("strong",[e._v("（3）B Tree 和 B+Tree 区别")])]),e._v(" "),_("p",[e._v("1、B Tree的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+Tree 的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。")]),e._v(" "),_("p",[e._v("2、在 B Tree 中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+Tree 中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。")]),e._v(" "),_("p",[e._v("B Tree：")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/7CEAE1608C59408095728DCA243739FC/11038",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/7CEAE1608C59408095728DCA243739FC/11038"),_("OutboundLink")],1)]),e._v(" "),_("p",[e._v("B+Tree：")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/78D503A724FB43B6B73282251C35CC90/11040",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/78D503A724FB43B6B73282251C35CC90/11040"),_("OutboundLink")],1)]),e._v(" "),_("p",[_("strong",[e._v("（4）MySQL 选择 B+Tree原因")])]),e._v(" "),_("ol",[_("li",[e._v("B+Tree 是 B Tree 的变种， B Tree 能解决的问题，B+Tree 也能够解决（降低树的高度，增大节点存储数据量）。")]),e._v(" "),_("li",[e._v("B+Tree 扫库和扫表能力更强。如果我们要根据索引去进行数据表的扫描，对 B Tree 进行扫描，需要把整棵树遍历一遍，而 B+Tree 只需要遍历他的所有叶子节点即可（叶子节点之间有引用）。")]),e._v(" "),_("li",[e._v("B+Tree 磁盘读写能力更强。他的根节点和支节点不保存数据区，所以根节点和支节点同样大小的情况下，保存的关键字要比 B Tree 要多。而叶子节点不保存子节点引用，能用于保存更多的关键字和数据。所以，B+Tree 读写一次磁盘加载的关键字比 B Tree 更多。")]),e._v(" "),_("li",[e._v("B+Tree 排序能力更强。上面的图中可以看出，B+Tree 天然具有排序功能。")]),e._v(" "),_("li",[e._v("B+Tree 查询性能稳定。B+Tree 数据只保存在叶子节点，每次查询数据，查询 IO 次数一定是稳定的。")])]),e._v(" "),_("p",[_("strong",[e._v("哈希索引")])]),e._v(" "),_("p",[e._v("简要说下，类似于数据结构中简单实现的 HASH 表（散列表）一样，当我们在 MySQL 中用哈希索引时，主要就是通过 Hash 算法（常见的 Hash 算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的 Hash 值，与这条数据的行指针一并存入 Hash 表的对应位置；如果发生 Has h碰撞（两个不同关键字的 Hash 值相同），则在对应 Hash 键下以链表形式存储。当然这只是简略模拟图：")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/3389A4430C9F47C5BE559B46207E8B65/10967",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/3389A4430C9F47C5BE559B46207E8B65/10967"),_("OutboundLink")],1)]),e._v(" "),_("p",[_("strong",[e._v("11.1.4 索引的存储方法")])]),e._v(" "),_("p",[_("strong",[e._v("聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据")]),e._v("。")]),e._v(" "),_("p",[_("strong",[e._v("非聚簇索引：将数据存储与索引分开结构，索引结构的叶子节点指向了数据对应的位置。")])]),e._v(" "),_("p",[_("strong",[e._v("一个表只能有一个聚集索引，可以有多个非聚集索引。")])]),e._v(" "),_("p",[e._v("在 InnoDB 中，在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。辅助索引叶子节点存储的不再是行的物理位置，而是主键值，辅助索引访问数据总是需要二次查找。")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/969ACCD0F2F44D4F81BEA924F08F24FD/11092",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/969ACCD0F2F44D4F81BEA924F08F24FD/11092"),_("OutboundLink")],1)]),e._v(" "),_("p",[_("strong",[e._v("1、InnoDB")])]),e._v(" "),_("ul",[_("li",[e._v("InnoDB 使用的是聚簇索引，将主键组织到一棵 B+Tree 中，而行数据就储存在叶子节点上，若使用 “where id =14” 这样的条件查找主键，则按照 B+Tree 的检索算法即可查找到对应的叶节点，之后获得行数据。")]),e._v(" "),_("li",[e._v("若对 Name 列进行条件搜索，则需要两个步骤：第一步在辅助索引 B+Tree 中检索 Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引 B+Tree 种再执，行一次 B+Tree 检索操作，最终到达叶子节点即可获取整行数据（重点在于通过其他键需要建立辅助索引）。")]),e._v(" "),_("li",[_("strong",[e._v("聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一且非空的索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键（类似 Oracle 中的 Rowld）来作为聚簇索引。如果已经设置了主键为聚簇索引又希望再单独设置聚簇索引，必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可。")])])]),e._v(" "),_("p",[_("strong",[e._v("2、 MYISAM")])]),e._v(" "),_("ul",[_("li",[e._v("MyISAM 使用的是非聚簇索引，非聚簇索引的两棵 B+Tree 看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主健索引 B+Tree 的节点存储了主键，辅助键索引 B+Tree 存储了辅助键。表数据存储在独立的地方，这两颗 B+Tree 的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。")])]),e._v(" "),_("p",[_("a",{attrs:{href:"https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/98D525E1F134450DAC2C2DAFC8F50239/11109",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/98D525E1F134450DAC2C2DAFC8F50239/11109"),_("OutboundLink")],1)]),e._v(" "),_("p",[_("strong",[e._v("11.1.5 主键通常建议使用 id 自增的原因")])]),e._v(" "),_("p",[e._v("聚簇索引的数据的物理存放顺序和索引顺存是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增id，那么可以想象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些指施来减少这些操作，但却无去彻底避免。但，如果是自增的，那就简单了，它只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。")]),e._v(" "),_("p",[_("strong",[e._v("11.1.6 创建索引的原则")])]),e._v(" "),_("p",[e._v("（1）表的主键、外键必须有索引；")]),e._v(" "),_("p",[e._v("（2）数据量超过 300 的表应该有索引；")]),e._v(" "),_("p",[e._v("（3）经常与其他表进行连接的表，在连接字段上应该建立索引；")]),e._v(" "),_("p",[e._v("（4）经常出现在 where 子句中的字段，特别是大表的字段，应该建立索引；")]),e._v(" "),_("p",[e._v("（5）索引应该建在选择性高的字段上；")]),e._v(" "),_("p",[e._v("（6）索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；")]),e._v(" "),_("p",[e._v("（7）复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替：")]),e._v(" "),_("p",[e._v("A、正确选择复合索引中的主列字段，一般是选择性较好的字段；")]),e._v(" "),_("p",[e._v("B、复合索引的几个字段是否经常同时以 AND 方式出现在 where 子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；")]),e._v(" "),_("p",[e._v("C、如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；")]),e._v(" "),_("p",[e._v("D、如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；")]),e._v(" "),_("p",[e._v("（8）频繁进行数据操作的表，不要建立太多的索引；")]),e._v(" "),_("p",[e._v("（9）删除无用的索引，避免对执行计划造成负面影响")]),e._v(" "),_("p",[e._v("（10）最左前缀匹配原则，组合索引非常重要的原则")]),e._v(" "),_("p",[_("strong",[e._v("11.1.7 MySQL 回表、索引覆盖、索引下推")])]),e._v(" "),_("p",[e._v("准备：创建一张表，并创建一个自增主键索引和一个组合索引")]),e._v(" "),_("p",[_("strong",[_("code",[e._v("CREATE TABLE index_opt_test (")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("id int(11) NOT NULL AUTO_INCR (42.800, 0.280, 0.66%)EMENT,")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("name varchar(11) DEFAULT NULL,")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("title varchar(11) DEFAULT NULL,")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("age int(11) DEFAULT NULL,")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("sex varchar(11) DEFAULT NULL,")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("content varchar(500) DEFAULT NULL,")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("PRIMARY KEY (id),")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v("KEY idx_cb (name,title,age)")])])]),e._v(" "),_("p",[_("strong",[_("code",[e._v(") ENGINE=InnoDB;")])])]),e._v(" "),_("p",[_("strong",[e._v("回表")]),e._v("：回表是发生在二级索引上的一种数据查询操作，简单点讲就是我们要查询的列不在二级索引的列中，那么就必须根据二级索引查到主键 ID，然后再根据主键 ID 到聚簇索引树上去查询整行的数据，这一过程就叫作回表。")]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select id, name, age, sex from index_opt_test where name='cc' and title='T7' and age=35;")])])]),e._v(" "),_("p",[e._v("解析：SQL 需要查询的列包括 id、name、age、sex，查询条件命中索引 idx_cb，其中列 id、name、age 都在索引 idx_cb 中可以获取到，但是 sex 不能通过索引获取到，必须要获取到整行数据之后再从结果中捞出来 sex 列的数据，这种情况就必须要回表。")]),e._v(" "),_("p",[_("strong",[e._v("索引覆盖")]),e._v("：当 SQL 语句中查询的列都在索引中时，我们就不需要回表去把整行数据都捞出来了，可以从非聚簇索引树中直接获取到我们需要的列的数据，这就叫索引覆盖。简单点来讲就是：所有不需要回表的查询操作都叫索引覆盖。")]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select id, name, age from index_opt_test where name='cc' and title='T7';")])])]),e._v(" "),_("p",[e._v("解析：这条 SQL 要查询的列 id、name、age 全部都能从非聚簇索引 idx_cb 中直接查询出来，可能会有个疑问：我们的索引列是 name、title 和 age，为什么 id 明明不在组合索引中却还能发生索引覆盖？提出这个问题的同学真的是欠我一顿小烧烤，非聚簇索引的叶子节点里存的是什么东西：主键的关键字啊，我们这里主键是 id，他的关键字就是 id 的值啊，那我们通过非聚簇索引是不是可以直接将主键 id 查出来，是不是就不用再回表了，不用回表是不是就发生了索引覆盖啊，就是那么简单。")]),e._v(" "),_("p",[_("strong",[e._v("索引下推")]),e._v("：索引下推又叫索引条件下推（Index Condition Pushdown，简称 ICP），ICP 默认是开启的，使用 ICP 可以减少存储引擎访问基础表的次数和 Server 访问存储引擎的次数。")]),e._v(" "),_("p",[_("strong",[_("code",[e._v("select * from tuser where name like '张 %' and age=10 and ismale=1;")])])]),e._v(" "),_("p",[e._v("1、根据（username,age）联合索引查询所有满足名称以 “张” 开头的索引，然后回表查询出相应的全行数据，然后再筛选出满足年龄小于等于 10 的用户数据。过程如下图：")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/06EDE0E75A3F4AAAA501E98770CA5559/8775",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/06EDE0E75A3F4AAAA501E98770CA5559/8775"),_("OutboundLink")],1)]),e._v(" "),_("p",[e._v("2、根据（username,age）联合索引查询所有满足名称以 “张” 开头的索引，然后直接再筛选出年龄小于等于 10 的索引，之后再回表查询全行数据。过程如下图：")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/EE2CA228BA314ECFA1E9F0F8F4095CC8/8774",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/EE2CA228BA314ECFA1E9F0F8F4095CC8/8774"),_("OutboundLink")],1)]),e._v(" "),_("p",[e._v("明显的，第二种方式需要回表查询的全行数据比较少，这就是 MySQL 的索引下推。MySQL 默认启用索引下推，我们也可以通过修改系统变量 optimizer_switch 的 index_condition_pushdown 标志来控制。")]),e._v(" "),_("p",[_("strong",[_("code",[e._v("SET optimizer_switch = 'index_condition_pushdown=off';")])])]),e._v(" "),_("p",[e._v("注意点：")]),e._v(" "),_("p",[_("strong",[e._v("（1）InnoDB 引擎的表，索引下推只能用于二级索引。")])]),e._v(" "),_("p",[_("strong",[e._v("（2）索引下推一般可用于所求查询字段（select列）不是或不全是联合索引的字段，查询条件为多条件查询且查询条件子句（where/order by）字段全是联合索引。")])]),e._v(" "),_("p",[_("strong",[e._v("11.1.8 explain 详解")])]),e._v(" "),_("p",[e._v("用到 explain 这个命令来查看一个这些 SQL 语句的执行计划。")]),e._v(" "),_("ul",[_("li",[_("p",[_("strong",[_("code",[e._v("- 查看SQL是否使用索引，前面加上explain即可")])])]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("explain select*from emp where name='Jefabc';\n")])])])])]),e._v(" "),_("p",[_("a",{attrs:{href:"https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/77F6A6EB74B24580B4FFF68D3A59F886/12845",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/77F6A6EB74B24580B4FFF68D3A59F886/12845"),_("OutboundLink")],1)]),e._v(" "),_("p",[e._v("expain 出来的信息有 10 列，分别是 id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra。")]),e._v(" "),_("ul",[_("li",[_("strong",[e._v("id：选择标识符")])]),e._v(" "),_("li",[_("strong",[e._v("select_type：表示查询的类型。")])]),e._v(" "),_("li",[_("strong",[e._v("table：输出结果集的表")])]),e._v(" "),_("li",[_("strong",[e._v("partitions：匹配的分区")])]),e._v(" "),_("li",[_("strong",[e._v("type：表示表的连接类型")])]),e._v(" "),_("li",[_("strong",[e._v("possible_keys：表示查询时，可能使用的索引")])]),e._v(" "),_("li",[_("strong",[e._v("key：表示实际使用的索引")])]),e._v(" "),_("li",[_("strong",[e._v("key_len：索引字段的长度")])]),e._v(" "),_("li",[_("strong",[e._v("ref：列与索引的比较")])]),e._v(" "),_("li",[_("strong",[e._v("rows：扫描出的行数(估算的行数)")])]),e._v(" "),_("li",[_("strong",[e._v("filtered：按表条件过滤的行百分比")])]),e._v(" "),_("li",[_("strong",[e._v("Extra：执行情况的描述和说明")])])]),e._v(" "),_("p",[_("strong",[e._v("一、 id")])]),e._v(" "),_("p",[e._v("SELECT 识别符。这是 SELECT 的查询序列号。")]),e._v(" "),_("p",[e._v("SQL 执行的顺序的标识，SQL 从大到小的执行：")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("id 相同时，执行顺序由上至下。")])]),e._v(" "),_("li",[_("p",[e._v("如果是子查询，id 的序号会递增，id 值越大优先级越高，越先被执行。")])]),e._v(" "),_("li",[_("p",[e._v("id 如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id 值越大，优先级越高，越先执行。")])])]),e._v(" "),_("ul",[_("li",[_("p",[_("strong",[_("code",[e._v("- 查看在研发部并且名字以Jef开头的员工，经典查询")])])]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("explain select e.no, e.namefrom emp e left join dept d on e.dept_no= d.no where e.name like'Jef%' and d.name='研发部';\n")])])])])]),e._v(" "),_("p",[_("a",{attrs:{href:"https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/E2DC70D3B66F47F490C874B1A2025857/12866",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/E2DC70D3B66F47F490C874B1A2025857/12866"),_("OutboundLink")],1)]),e._v(" "),_("p",[_("strong",[e._v("二、select_type")])]),e._v(" "),_("p",[e._v("表示查询中每个 select 子句的类型")]),e._v(" "),_("p",[e._v("（1）"),_("strong",[e._v("SIMPLE")]),e._v("（简单 SELECT，不使用 UNION 或子查询等）")]),e._v(" "),_("p",[e._v("（2）"),_("strong",[e._v("PRIMARY")]),e._v("（子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的 select 被标记为 PRIMARY）")]),e._v(" "),_("p",[e._v("（3）"),_("strong",[e._v("UNION")]),e._v("（UNION 中的第二个或后面的 SELECT 语句）")]),e._v(" "),_("p",[e._v("（4）"),_("strong",[e._v("UNION RESULT")]),e._v("（UNION 的结果，MySQL 选择使用临时表来完成 UNION 查询的去重工作）")]),e._v(" "),_("p",[_("strong",[_("code",[e._v("mysql>select * from uchome_space union select * from uchome_space")])])]),e._v(" "),_("p",[_("a",{attrs:{href:"https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/B3348057EF0D47C88B95B5217A0EA62E/12905",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/B3348057EF0D47C88B95B5217A0EA62E/12905"),_("OutboundLink")],1)]),e._v(" "),_("p",[e._v("（5）"),_("strong",[e._v("DEPENDENT SUBQUERY")]),e._v("（子查询中的第一个 SELECT，取决于外面的查询）")]),e._v(" "),_("p",[e._v("（6）"),_("strong",[e._v("DEPENDENT UNION")]),e._v("（UNION中 的第二个或后面的 SELECT 语句，取决于外面的查询）")]),e._v(" "),_("p",[e._v("（7）"),_("strong",[e._v("SUBQUERY")]),e._v("（子查询中的第一个 SELECT，结果不依赖于外部查询）")]),e._v(" "),_("p",[e._v("（8）"),_("strong",[e._v("DERIVED")]),e._v("（派生表的 SELECT，FROM 子句的子查询，MySQL会将结果存放在一个临时表中，也称为派生表）")]),e._v(" "),_("p",[_("strong",[_("code",[e._v("explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;")])])]),e._v(" "),_("p",[_("a",{attrs:{href:"https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/A98FD3B7D2164AF38958FBABF119CB3D/12914",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/A98FD3B7D2164AF38958FBABF119CB3D/12914"),_("OutboundLink")],1)]),e._v(" "),_("p",[e._v("（9）"),_("strong",[e._v("UNCACHEABLE SUBQUERY")]),e._v("（一个子查询的结果不能被缓存，必须重新评估外链接的第一行）")]),e._v(" "),_("p",[_("strong",[e._v("三、table")])]),e._v(" "),_("p",[e._v("显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的），有时不是真实的表名字，可能是简称，例如上面的 e，d，也可能是第几步执行的结果的简称（别名）。")]),e._v(" "),_("p",[_("strong",[e._v("四、type")])]),e._v(" "),_("p",[e._v("对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。")]),e._v(" "),_("p",[e._v("常用的类型有： "),_("strong",[e._v("ALL、index、range、 ref、eq_ref、const、system、NULL")]),e._v("（从左到右，性能从差到好）。")]),e._v(" "),_("ul",[_("li",[_("strong",[e._v("ALL：Full Table Scan， MySQL 将遍历全表以找到匹配的行。")])]),e._v(" "),_("li",[_("strong",[e._v("index：Full Index Scan，index 与 ALL 区别为 index 类型只遍历索引树。")])]),e._v(" "),_("li",[_("strong",[e._v("range：只检索给定范围的行，使用一个索引来选择行。")])]),e._v(" "),_("li",[_("strong",[e._v("ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。")])]),e._v(" "),_("li",[_("strong",[e._v("eq_ref:：类似 ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用 primary key 或者 unique key 作为关联条件。")])]),e._v(" "),_("li",[_("strong",[e._v("const、system：当 MySQL 对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量，system 是 const 类型的特例，当查询的表只有一行的情况下，使用 system。")])]),e._v(" "),_("li",[_("strong",[e._v("NULL：MySQL 在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。")])])]),e._v(" "),_("p",[_("strong",[e._v("五、possible_keys")])]),e._v(" "),_("p",[e._v("指出 MySQL 能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用（该查询可以利用的索引，如果没有任何索引显示 null）")]),e._v(" "),_("p",[e._v("该列完全独立于 EXPLAIN 输出所示的表的次序。这意味着在 possible_keys中 的某些键实际上不能按生成的表次序使用。")]),e._v(" "),_("p",[e._v("如果该列是 NULL，则没有相关的索引。在这种情况下，可以通过检查 WHERE 子句看是否它引用某些列或适合索引的列来提高你的查询性能。如果是这样，创造一个适当的索引并且再次用 EXPLAIN 检查查询。")]),e._v(" "),_("p",[_("strong",[e._v("六、Key")])]),e._v(" "),_("p",[e._v("key 列显示 MySQL 实际决定使用的键（索引），必然包含在 possible_keys 中。")]),e._v(" "),_("p",[e._v("如果没有选择索引，键是 NULL。要想强制 MySQL 使用或忽视 possible_keys 列中的索引，在查询中使用 FORCE INDEX、USE INDEX 或者 IGNORE INDEX。")]),e._v(" "),_("p",[_("strong",[e._v("七、key_len")])]),e._v(" "),_("p",[e._v("表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len 显示的值为索引字段的最大可能长度，并非实际使用长度，即 key_len 是根据表定义计算而得，不是通过表内检索出的）。")]),e._v(" "),_("p",[e._v("不损失精确性的情况下，长度越短越好 。")]),e._v(" "),_("p",[_("strong",[e._v("八、ref")])]),e._v(" "),_("p",[e._v("列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值，常见的有：const（常量），字段名（例：t1.id）。")]),e._v(" "),_("p",[_("strong",[e._v("九、rows")])]),e._v(" "),_("p",[e._v("估算出结果集行数，表示 MySQL 根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数。")]),e._v(" "),_("p",[_("strong",[e._v("十、Extra")])]),e._v(" "),_("p",[e._v("该列包含 MySQL 解决查询的详细信息,有以下几种情况：")]),e._v(" "),_("ul",[_("li",[_("p",[_("strong",[e._v("Using where：不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示 MySQL 服务器将在存储引擎检索行后再进行过滤。")])])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("Using temporary：表示 MySQL 需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by、order by。")])])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("Using filesort：当 Query 中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”。")])])]),e._v(" "),_("li",[_("p",[_("strong",[_("code",[e._v("- 测试Extra的filesort")])])]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("explain select*from emp order by name;\n")])])])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。")])])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("Impossible where：这个值强调了 where 语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。")])])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行。")])])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("No tables used：Query 语句中使用 from dual 或不含任何 from 子句")])])]),e._v(" "),_("li",[_("p",[_("strong",[_("code",[e._v("- explain select now() from dual;")])])])])]),e._v(" "),_("p",[_("strong",[e._v("11.1.9 索引相关问题")])]),e._v(" "),_("p",[_("strong",[e._v("（一）IN 造成的索引失效")])]),e._v(" "),_("p",[e._v("在 MySQL 的官方手册上有这么一句话:")]),e._v(" "),_("p",[_("strong",[e._v("the optimizer can estimate the row count for each range using dives into the index or index statistics.")])]),e._v(" "),_("p",[e._v("这是在说: 优化器为每一个范围段（如 “a IN (10, 20, 30)” 是等值比较, 括 3 个范围段实则简化为 3 个单值,分别是10，20，30）估计每个范围段（用范围段来表示是因为 MySQL 的 “range” 扫描方式多数做的是范围扫描，此处单值可视为范围段的特例）中包括的元组数, 而估计方法有 2 种,一是 dive到 index 中即利用索引完成元组数的估算,简称 index dive； 二是使用索引的统计数值，进行估算。")]),e._v(" "),_("p",[e._v("相比这2种方式，在效果上:")]),e._v(" "),_("p",[_("strong",[e._v("1、index dive")])]),e._v(" "),_("p",[e._v("统计速度慢但是能得到精准的值。")]),e._v(" "),_("p",[e._v("计算成本方式：COST = CPU COST + IO COST。")]),e._v(" "),_("p",[e._v("COST 是总花销时间，CPU COST 是处理返回记录数据花销时间，IO COST 是操作IO所花销的时间。")]),e._v(" "),_("p",[e._v("MySQL 会对查询条件中用到的每个索引进行上述成本估算，最后以最小成本来选择索引执行 SQL。")]),e._v(" "),_("p",[_("strong",[e._v("2、index statistics")])]),e._v(" "),_("p",[e._v("统计速度快但是数据不精准。")]),e._v(" "),_("p",[e._v("计算成本方式：SHOW INDEX FROM tbl_name [FROM db_name]。")]),e._v(" "),_("p",[e._v("查询出来的结果中有一个列名为 Cardinality，表示索引列中不重复值得个数（即唯一值得个数），这个值越大说明数据区分度越高，优化器会选择 Cardinality 值最高的索引，反之优化器会认为这个索引对语句查询没有太大帮助而放弃选择该索引。")]),e._v(" "),_("p",[e._v("在使用 IN 或者 OR 等条件进行查询时，MySQL 使用 eq_range_index_dive_limit 参数来判断使用 index dive 还是使用 index statistics 方式来进行预估：")]),e._v(" "),_("p",[_("strong",[e._v("1、当低于eq_range_index_dive_limit参数阀值时，采用index dive方式预估影响行数，该方式优点是相对准确，但不适合对大量值进行快速预估。")])]),e._v(" "),_("p",[_("strong",[e._v("2、当大于或等于eq_range_index_dive_limit参数阀值时，采用index statistics方式预估影响行数，该方式优点是计算预估值的方式简单，可以快速获得预估数据，但相对偏差较大。")])]),e._v(" "),_("p",[_("strong",[e._v("在MySQL 5.6版本中引入eq_range_index_dive_limit参数，默认值为10，通常业务在使用IN时会超过10个值，因此在MySQL 5.7版本中将默认阀值设为200。")])]),e._v(" "),_("p",[_("strong",[e._v("（二）order by 索引")])]),e._v(" "),_("p",[e._v("当 order by 中的字段出现在 where 条件中时，才会利用索引而不排序，更准确的说，order by 中的字段在执行计划中利用了索引时，不用排序操作。")]),e._v(" "),_("p",[e._v("这个结论不仅对 order by 有效，对其他需要排序的操作也有效。比如 group by 、union 、distinct 等。")]),e._v(" "),_("p",[_("strong",[e._v("（三）为什么重复值高的字段不能建索引（比如性别字段等)")])]),e._v(" "),_("p",[_("a",{attrs:{href:"https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/DB55F833B0C44BFFA49C3A7882AA7F65/11343",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://note.youdao.com/yws/public/resource/6e8acc1f5e9f21e06c00d6f712919e2d/xmlnote/DB55F833B0C44BFFA49C3A7882AA7F65/11343"),_("OutboundLink")],1)]),e._v(" "),_("p",[e._v("结论（以InnoDB为例）:")]),e._v(" "),_("ol",[_("li",[e._v("非聚簇索引存储了对主键的引用，如果 select 字段不在非聚簇索引内，就需要跳到主键索引（上图中从右边的索引树跳到左边的索引树），再获取 select 字段值。")]),e._v(" "),_("li",[e._v("如果非聚簇索引值重复率高，那么查询时就会大量出现上图中从右边跳到左边的情况，导致整个流程很慢。")]),e._v(" "),_("li",[e._v("不建议在值重复率高的字段上建索引，因为查询效率低，还需要维护索引。")])])])}),[],!1,null,null,null);_.default=r.exports}}]);