(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{344:function(v,_,a){v.exports=a.p+"assets/img/1.916544b9.png"},345:function(v,_,a){v.exports=a.p+"assets/img/2.eb3b9fa3.png"},346:function(v,_,a){v.exports=a.p+"assets/img/3.78916b77.png"},347:function(v,_,a){v.exports=a.p+"assets/img/4.2b8eddf5.png"},348:function(v,_,a){v.exports=a.p+"assets/img/5.70a6c7e1.png"},349:function(v,_,a){v.exports=a.p+"assets/img/6.24e21d56.png"},350:function(v,_,a){v.exports=a.p+"assets/img/7.2374ad75.png"},351:function(v,_,a){v.exports=a.p+"assets/img/8.fc8ce21f.png"},352:function(v,_,a){v.exports=a.p+"assets/img/9.50f86d22.png"},353:function(v,_,a){v.exports=a.p+"assets/img/10.e3a773ed.png"},354:function(v,_,a){v.exports=a.p+"assets/img/11.84e0f4b3.png"},439:function(v,_,a){"use strict";a.r(_);var l=a(3),i=Object(l.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"jvm"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm"}},[v._v("#")]),v._v(" JVM")]),v._v(" "),_("h3",{attrs:{id:"jvm的体系结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm的体系结构"}},[v._v("#")]),v._v(" jvm的体系结构")]),v._v(" "),_("ol",[_("li",[v._v("程序计数器: 当前线程所执行字节码的"),_("strong",[v._v("行号指示器")])]),v._v(" "),_("li",[v._v("java虚拟机栈: 描述java方法执行的线程内存模型: 每个方法被执行的时候,java虚拟机都会同步创建一个栈帧用于存储"),_("strong",[v._v("局部变量表、操作数栈、动态链接、方法出口")]),v._v("等信息, 每一个方法被调用直至执行完毕的过程, 就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程")]),v._v(" "),_("li",[v._v("本地方法栈: 和虚拟机栈类似, 不过是为本地方法服务, 虚拟机栈为java方法(字节码)服务")]),v._v(" "),_("li",[v._v("堆: 存放"),_("strong",[v._v("对象实例")])]),v._v(" "),_("li",[v._v("方法区:存储被"),_("strong",[v._v("虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码")]),v._v("缓存等数据")])]),v._v(" "),_("p",[_("img",{attrs:{src:a(344),alt:""}})]),v._v(" "),_("p",[_("img",{attrs:{src:a(345),alt:""}})]),v._v(" "),_("p",[_("img",{attrs:{src:a(346),alt:""}})]),v._v(" "),_("h3",{attrs:{id:"类加载过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类加载过程"}},[v._v("#")]),v._v(" 类加载过程")]),v._v(" "),_("p",[_("img",{attrs:{src:a(347),alt:""}})]),v._v(" "),_("ol",[_("li",[v._v("加载\n"),_("ol",[_("li",[v._v("通过一个类的全限定名获取定义此类的二进制字节流")]),v._v(" "),_("li",[v._v("将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构")]),v._v(" "),_("li",[v._v("在内存中生成一个代表这个类的class对象, 作为方法区这个类的各种数据的访问入口")])])]),v._v(" "),_("li",[v._v("链接\n"),_("ol",[_("li",[v._v("验证\n"),_("ol",[_("li",[v._v("目的在于确保class文件的字节流中包含的信息符合当前虚拟机要求,保证被加载类的正确性, 不会危害虚拟机自身安全")]),v._v(" "),_("li",[v._v("主要包括: 文件格式校验, 元数据验证, 字节码验证, 符号引用验证")]),v._v(" "),_("li",[v._v("简单说就是校验合法性")])])]),v._v(" "),_("li",[v._v("准备\n"),_("ol",[_("li",[v._v("为类变量(静态成员变量)分配内存并且设置该类变量的默认初始值, 即零值")]),v._v(" "),_("li",[v._v("这里不包含用final修饰的static , 因为final在编译的时候就会分配, 准备阶段会显式初始化")]),v._v(" "),_("li",[v._v("这里不会为实例变量(非静态成员变量)分配初始化, 类变量会分配在方法区中, 而实例变量是会随着对象一起分配到java堆中")])])]),v._v(" "),_("li",[v._v("解析\n"),_("ol",[_("li",[v._v("将常量池内的符号引用转换为直接引用的过程")]),v._v(" "),_("li",[v._v("事实上, 解析操作往往会伴随JVM在执行完初始化之后在执行")])])])])]),v._v(" "),_("li",[v._v("初始化\n"),_("ol",[_("li",[v._v("给类变量量显式赋值")])])])]),v._v(" "),_("h3",{attrs:{id:"类加载器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[v._v("#")]),v._v(" 类加载器")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("启动类加载器")]),v._v(" "),_("p",[v._v("用来加载java核心类库, 加载位于/jre/lib目录中的或者被参数 -Xbootclasspath所指定的目录下的核心java类库, 无法被java程序直接引用")])]),v._v(" "),_("li",[_("p",[v._v("扩展类加载器")]),v._v(" "),_("p",[v._v("它用来加载java的拓展库, java虚拟机的实现会提供一个扩展库目录, 加载位于/jre/lib/ext目录中的或者java.ext.dirs系统变量所指定的目录下的拓展类库, 该类加载器在此目录里面查找并加载java类")])]),v._v(" "),_("li",[_("p",[v._v("系统类加载器")]),v._v(" "),_("p",[v._v("它根据java应用的类路径来加载java类, 一般来说, java应用的类都是由它来加载的, 可以通过ClassLoader.getSystemClassLoader()来获取")])]),v._v(" "),_("li",[_("p",[v._v("用户自定义类加载器")]),v._v(" "),_("p",[v._v("通过继承java.lang.ClassLoader类的方式实现")]),v._v(" "),_("ul",[_("li",[v._v("我们需要的类不一定存放在已经设置好的 classPath 下（有系统类加载器 AppClassLoader 加载的路径），对于自定义路径中的 class 类文件的加载，我们需要自己的 ClassLoader。")]),v._v(" "),_("li",[v._v("有时我们不一定是从类文件中读取类，可能是从网络的输入流中读取类，这就需要做一些加密和解密操作，这就需要自己实现加载类的逻辑，当然其他的特殊处理也同样适用。")]),v._v(" "),_("li",[v._v("可以定义类的实现机制，实现类的热部署,如 OSGi 中的 bundle 模块就是通过实现自己的 ClassLoader 实现的。")])])])]),v._v(" "),_("h3",{attrs:{id:"双亲委派机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派机制"}},[v._v("#")]),v._v(" 双亲委派机制")]),v._v(" "),_("ol",[_("li",[v._v("工作原理\n"),_("ol",[_("li",[v._v("如果一个类加载器收到了类加载请求, 他并不会自己先加载, 而是把这个请求委托给父类的加载器去执行")]),v._v(" "),_("li",[v._v("如果父类存在父类加载器, 则进一步向上委托,依次递归, 请求最终将到达顶层的启动类加载器")]),v._v(" "),_("li",[v._v("如果父类加载器可以完成类加载任务, 就成功返回,")]),v._v(" "),_("li",[v._v("如果父类无法完成则向下子类尝试加载")])])]),v._v(" "),_("li",[v._v("目的\n"),_("ol",[_("li",[v._v("避免类的重复加载")]),v._v(" "),_("li",[v._v("保护程序安全, 防止核心api被随机篡改")])])])]),v._v(" "),_("p",[_("img",{attrs:{src:a(348),alt:""}}),v._v(")")]),v._v(" "),_("h3",{attrs:{id:"gc的作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#gc的作用域"}},[v._v("#")]),v._v(" GC的作用域")]),v._v(" "),_("p",[v._v("方法区和堆")]),v._v(" "),_("h3",{attrs:{id:"常见垃圾回收算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见垃圾回收算法"}},[v._v("#")]),v._v(" 常见垃圾回收算法")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("引用计数: 引用依次计数+1, 如果计数为0表示没引用可清除\n缺点: 每次对象赋值都要维护引用计数器, 且计数器本身也有消耗; 较难处理循环引用\nJVM的实现一般不采用")])]),v._v(" "),_("li",[_("p",[v._v("复制")]),v._v(" "),_("p",[v._v("一般用于新生代(又细分Eden区、From Survivor区和 To Survivor区)   比例8:1:1")]),v._v(" "),_("p",[v._v("过程: 复制→清空→互换")]),v._v(" "),_("p",[v._v("将eden和FormSurvivor中还存活的对象拷贝到ToSurvivor中, 同时这些对象年龄+1")]),v._v(" "),_("p",[v._v("清空eden和FormSurvivor中的对象")]),v._v(" "),_("p",[v._v("FormSurvivor和ToSurvivor身份互换, 谁空谁是to; 如果两个区交换15次后,还存活进入老年代")])]),v._v(" "),_("li",[_("p",[v._v("标记清除")]),v._v(" "),_("p",[v._v("一般用于老生代, 分为标记和清除两个阶段, 先标记出要回收的对象, 然后同一回收\n缺点: 内存碎片过多, 不连续")])]),v._v(" "),_("li",[_("p",[v._v("标记整理")]),v._v(" "),_("p",[v._v("一般用于老生代, 分为标记和压缩两步, 先标记,然后再次扫描, 并向一端滑动存活数据, 没有内存碎片")]),v._v(" "),_("p",[v._v("缺点: 需要移动对象")])])]),v._v(" "),_("h3",{attrs:{id:"jvm垃圾回收时如何确定对象-什么是gc-roots"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm垃圾回收时如何确定对象-什么是gc-roots"}},[v._v("#")]),v._v(" JVM垃圾回收时如何确定对象? 什么是GC Roots?")]),v._v(" "),_("p",[v._v("垃圾: 简单来说就是内存中已经不再被使用的空间就是垃圾")]),v._v(" "),_("p",[v._v("怎么确定可以被回收:")]),v._v(" "),_("ol",[_("li",[v._v("引用计数法: 维护引用计数, 已经不使用了")]),v._v(" "),_("li",[v._v("枚举根节点做可达性分析(跟搜索路径)")])]),v._v(" "),_("p",[v._v("GC Roots 就是一组必须活跃的引用")]),v._v(" "),_("p",[v._v("通过GC Roots 为起始点, 向下搜索, 如果一个对象到起始点没有任何引用链相连时, 则说明该对象不可用.")]),v._v(" "),_("p",[v._v("可做GC Roots的对象:")]),v._v(" "),_("ol",[_("li",[v._v("虚拟机栈(栈帧中的局部变量区, 也叫作局部变量表)中引用的对象")]),v._v(" "),_("li",[v._v("方法区中的类常量属性引用的对象")]),v._v(" "),_("li",[v._v("方法区中常量引用的对象")]),v._v(" "),_("li",[v._v("本地方法区中JNI(Native方法)引用的对象")])]),v._v(" "),_("h3",{attrs:{id:"jvm参数类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm参数类型"}},[v._v("#")]),v._v(" JVM参数类型")]),v._v(" "),_("ol",[_("li",[v._v("标配参数: 各个版本一直没变\n"),_("ol",[_("li",[v._v("-version")]),v._v(" "),_("li",[v._v("-help")]),v._v(" "),_("li",[v._v("-showversion")])])]),v._v(" "),_("li",[v._v("X参数(了解)\n"),_("ol",[_("li",[v._v("-Xint 解释运行")]),v._v(" "),_("li",[v._v("-Xcomp  第一次使用就编译成本地代码")]),v._v(" "),_("li",[v._v("-Xmixed  混合模式")])])]),v._v(" "),_("li",[v._v("XX参数(重点)\n"),_("ol",[_("li",[_("p",[v._v("布尔类型")]),v._v(" "),_("p",[v._v("语句格式: -XX:+/- 某个属性   + 表示开启  -表示关闭   查看某属性是否开启")]),v._v(" "),_("p",[v._v("1.是否打印GC收集细节")]),v._v(" "),_("p",[v._v("-XX:-PrintGCDetails   关闭")]),v._v(" "),_("p",[v._v("-XX:+PrintGCDetails  开启")]),v._v(" "),_("p",[v._v("在运行中查看是否开启 : jinfo -flag PrintGCDetails 进程号")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("是否使用串行垃圾回收器")]),v._v(" "),_("p",[v._v("-XX:-UserSerialGC")]),v._v(" "),_("p",[v._v("-XX:+UserSerialGC")])])])]),v._v(" "),_("li",[_("p",[v._v("KV设值类型")]),v._v(" "),_("p",[v._v("语句格式:  -XX属性key=属性值value")]),v._v(" "),_("ol",[_("li",[v._v("-XX:MetaspaceSize=128m     设置元空间初始值")]),v._v(" "),_("li",[v._v("-XX:MaxTenuringThreshold=15    设置年轻代到年老区的岁数")])])])])]),v._v(" "),_("li",[v._v("jps/jinfo\n"),_("ol",[_("li",[v._v("jps -l    查看当前进程  类似ps")]),v._v(" "),_("li",[v._v("jinfo -flags   查看所有属性")]),v._v(" "),_("li",[v._v("jinfo -flag 属性名   查看单个属性")])])])]),v._v(" "),_("h3",{attrs:{id:"xms和-xmx"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#xms和-xmx"}},[v._v("#")]),v._v(" -Xms和-Xmx")]),v._v(" "),_("p",[v._v("-Xms 等价于  -XX:InitialHeapSize    初始化堆内存")]),v._v(" "),_("p",[v._v("-Xmx 等价于 -XX:MaxHeapSize   最大堆内存")]),v._v(" "),_("h3",{attrs:{id:"查看初始默认值"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#查看初始默认值"}},[v._v("#")]),v._v(" 查看初始默认值")]),v._v(" "),_("ol",[_("li",[v._v("-XX:+PrintFlagsInitial      主要查看初始默认值\n"),_("ol",[_("li",[v._v("java -XX:+PrintFlagsInitial   可以添加在运行参数上也可以直接黑窗口用   查询出来的列表如果等号前有冒号代表修改过")])])]),v._v(" "),_("li",[v._v("-XX:+PrintFlagsFinal")]),v._v(" "),_("li",[v._v("-XX:+PrintCommandLineFlags")])]),v._v(" "),_("h3",{attrs:{id:"jvm常用配置参数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm常用配置参数"}},[v._v("#")]),v._v(" JVM常用配置参数")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("-Xms")]),v._v(" "),_("ol",[_("li",[v._v("初始化堆内存大小, 默认为物理内存的1/64")]),v._v(" "),_("li",[v._v("等价 -XX:InitialHeapSize")])])]),v._v(" "),_("li",[_("p",[v._v("-Xmx")]),v._v(" "),_("ol",[_("li",[v._v("最大分配堆内存, 默认为物理内存的1/4")]),v._v(" "),_("li",[v._v("等价 -XX:MaxHeapSize")])])]),v._v(" "),_("li",[_("p",[v._v("-Xss")]),v._v(" "),_("ol",[_("li",[v._v("设置单个线程栈的大小   一般默认512k-1024k")]),v._v(" "),_("li",[v._v("等价 -XX:ThreadStackSize")])])]),v._v(" "),_("li",[_("p",[v._v("-Xmm")]),v._v(" "),_("ol",[_("li",[v._v("设置年轻代的大小")])])]),v._v(" "),_("li",[_("p",[v._v("-XX:MetaspaceSize")]),v._v(" "),_("ol",[_("li",[v._v("元空间大小 : 元空间使用本地内存, 默认情况下,元空间的大小仅受本地内存限制")])])]),v._v(" "),_("li",[_("p",[v._v("-XX+PrintGCDetails")]),v._v(" "),_("ol",[_("li",[v._v("输出详细GC收集日志信息")])])]),v._v(" "),_("li",[_("p",[v._v("-XX:SurvivorRation")]),v._v(" "),_("ol",[_("li",[v._v("设置新生代中eden和s0/s1空间的比例")]),v._v(" "),_("li",[v._v("默认是8:1:1")]),v._v(" "),_("li",[v._v("例:   -XX:SurvivorRatio=4   设置eden的比例   也就是4:1:1")])])]),v._v(" "),_("li",[_("p",[v._v("-XX:NewRatio")]),v._v(" "),_("ol",[_("li",[v._v("配置新生代和老年代在堆结构的占比")]),v._v(" "),_("li",[v._v("默认是1:2")]),v._v(" "),_("li",[v._v("例:  -XX:NewRatio=4     设置的老年代的占比  新生代1 老年代4")])])]),v._v(" "),_("li",[_("p",[v._v("-XX:MaxTenuringThreshold")]),v._v(" "),_("ol",[_("li",[v._v("新生代经过几次GC后能到老年代")]),v._v(" "),_("li",[v._v("默认15次    设置范围0-15")])])]),v._v(" "),_("li",[_("p",[v._v("典型配置案例")]),v._v(" "),_("p",[v._v("-Xms128m -Xmx4096m -Xss1024k -XX:MetaspaceSize=512m -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:+UserSerialGC(默认是并行, 串行在服务器环境不用)")])])]),v._v(" "),_("h3",{attrs:{id:"引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#引用"}},[v._v("#")]),v._v(" 引用")]),v._v(" "),_("ol",[_("li",[v._v("强引用\n"),_("ol",[_("li",[v._v("平时我们=就是强引用, 不会被回收")]),v._v(" "),_("li",[v._v("例 : Object o1 = new Object();  Object o2 = o1; o1=null; System.gc();    这是o1回收了, o2不会回收")])])]),v._v(" "),_("li",[v._v("软引用\n"),_("ol",[_("li",[v._v("内存够用不回收, 内存不够用才回收")]),v._v(" "),_("li",[v._v("用java.lang.ref.SoftReference实现")]),v._v(" "),_("li",[v._v("例: "),_("code",[v._v("SoftReference<Object> softReference = new SoftReference<>(o1);")]),v._v("  这就是软引用,获取方法→softReference.get()")])])]),v._v(" "),_("li",[v._v("弱引用\n"),_("ol",[_("li",[v._v("只要进行垃圾清理, 都会回收")]),v._v(" "),_("li",[v._v("用java.lang.ref.WeakReference类实现")]),v._v(" "),_("li",[v._v("WeakHashMap")])])]),v._v(" "),_("li",[v._v("虚引用\n"),_("ol",[_("li",[v._v("需要用java.lang.ref.PhantomReference类实现")]),v._v(" "),_("li")])])]),v._v(" "),_("h3",{attrs:{id:"oom"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#oom"}},[v._v("#")]),v._v(" OOM")]),v._v(" "),_("ol",[_("li",[v._v("常见的\n"),_("ol",[_("li",[v._v("java.lang.StackOverflowError\n"),_("ol",[_("li",[v._v("栈溢出   比如递归深度过深")])])]),v._v(" "),_("li",[v._v("java.lang.OutOfMemoryError: java heap space\n"),_("ol",[_("li",[v._v("堆内存溢出")])])]),v._v(" "),_("li",[v._v("java.lang.OutOfMemoryError: GC overhead limit exceeded\n"),_("ol",[_("li",[v._v("GC回收时间过长, 超过98%的时间来GC并且回收了不到2%的堆内存")]),v._v(" "),_("li",[v._v("GC频繁执行,但是效果甚微,造成了循环GC")])])]),v._v(" "),_("li",[v._v("java.lang.OutOfMemoryError: Direct buffer memory\n"),_("ol",[_("li",[v._v("直接内存溢出")]),v._v(" "),_("li",[v._v("本地内存, 不属于GC范围, 本地内存用光了就会崩溃")]),v._v(" "),_("li",[v._v("一般出现在NIO程序中, NIO经常使用BateBuffer来读取和写入")]),v._v(" "),_("li",[v._v("ByteBuffer.allocateDirect()   会分配本地内存")])])]),v._v(" "),_("li",[v._v("java.lang.OutOfMemoryError: unable to create new native thread\n"),_("ol",[_("li",[v._v("导致原因:\n"),_("ol",[_("li",[v._v("你的应用创建了太多线程, 一个应用进程创建多个线程, 超过系统承载极限")]),v._v(" "),_("li",[v._v("你的服务器不允许你的应用创建这么多线程, linux系统默认单个进程可以创建的线程数是1024个")])])]),v._v(" "),_("li",[v._v("解决办法:\n"),_("ol",[_("li",[v._v("想办法降低应用创建线程的数量")]),v._v(" "),_("li",[v._v("修改linux的服务器配置, 扩大默认限制\n"),_("ol",[_("li",[v._v("ulimit -u  查看允许的线程数")]),v._v(" "),_("li",[v._v("vim /etc/security/limits.d/90-nproc.conf   修改这个文件")])])])])])])]),v._v(" "),_("li",[v._v("java.lang.OutOfMemoryError: Metaspace")])])])]),v._v(" "),_("h3",{attrs:{id:"垃圾回收器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器"}},[v._v("#")]),v._v(" 垃圾回收器")]),v._v(" "),_("ol",[_("li",[v._v("Serial  串行垃圾回收器\n"),_("ol",[_("li",[v._v("为单线程环境设计且只使用一个线程进行垃圾回收,会暂停所有的用户线程.  不适合服务器环境")])])]),v._v(" "),_("li",[v._v("Parallel  并行垃圾回收器\n"),_("ol",[_("li",[v._v("多个垃圾收集线程并行工作, 此时用户线程是暂停的, 适用于科学计算/大数据处理首台处理等弱交互场景")])])]),v._v(" "),_("li",[v._v("CMS  并发垃圾回收器\n"),_("ol",[_("li",[v._v("用户线程和垃圾收集线程同时执行(不一定并行,可能交替进行), 适用于对响应时间有要求的场景")])])]),v._v(" "),_("li",[v._v("G1垃圾回收器\n"),_("ol",[_("li",[v._v("将堆内存分割为不同的区域然后并发的对其进行垃圾回收")])])])]),v._v(" "),_("h3",{attrs:{id:"怎么查看和配置垃圾收集器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#怎么查看和配置垃圾收集器"}},[v._v("#")]),v._v(" 怎么查看和配置垃圾收集器")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("怎么查看配置的那种垃圾回收器?")]),v._v(" "),_("p",[v._v("java -XX:+PrintCommandLineFlags -version")])]),v._v(" "),_("li",[_("p",[v._v("配置垃圾回收器")]),v._v(" "),_("p",[v._v("-XX:+UserSerialGC")])])]),v._v(" "),_("h3",{attrs:{id:"默认的垃圾收集器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#默认的垃圾收集器"}},[v._v("#")]),v._v(" 默认的垃圾收集器")]),v._v(" "),_("p",[v._v("七种")]),v._v(" "),_("p",[v._v("UserSerialGC(java8已经淘汰了)")]),v._v(" "),_("p",[v._v("UserSerialGC")]),v._v(" "),_("p",[v._v("UseParallelGC")]),v._v(" "),_("p",[v._v("UseConcMarkSweepGC")]),v._v(" "),_("p",[v._v("UseParNewGC")]),v._v(" "),_("p",[v._v("UseParallelOldGC")]),v._v(" "),_("p",[v._v("UseG1GC")]),v._v(" "),_("p",[_("img",{attrs:{src:a(349),alt:""}})]),v._v(" "),_("p",[_("img",{attrs:{src:a(350),alt:""}})]),v._v(" "),_("h3",{attrs:{id:"如何选择垃圾收集器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何选择垃圾收集器"}},[v._v("#")]),v._v(" 如何选择垃圾收集器")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("单cpu或小内存, 单机程序")]),v._v(" "),_("p",[v._v("-XX:+UseSerialGC")])]),v._v(" "),_("li",[_("p",[v._v("多cpu, 需要最大吞吐量, 如后台计算型应用")]),v._v(" "),_("p",[v._v("-XX:+UseParallelGC 或者  -XX:+UseParallelOldGC")])]),v._v(" "),_("li",[_("p",[v._v("多cpu, 追求低停顿时间, 需要快速响应如互联网应用")]),v._v(" "),_("p",[v._v("-XX:+UseConcarkSweepGC    -XX:+ParNewGC")])])]),v._v(" "),_("p",[_("img",{attrs:{src:a(351),alt:""}})]),v._v(" "),_("h3",{attrs:{id:"g1收集器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#g1收集器"}},[v._v("#")]),v._v(" G1收集器")]),v._v(" "),_("p",[v._v("将堆划分不同小区域, 每个处理一小个区域")]),v._v(" "),_("p",[_("img",{attrs:{src:a(352),alt:""}})]),v._v(" "),_("p",[v._v("常用配置参数")]),v._v(" "),_("p",[_("img",{attrs:{src:a(353),alt:""}})]),v._v(" "),_("h3",{attrs:{id:"g1和cms的比较"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#g1和cms的比较"}},[v._v("#")]),v._v(" G1和CMS的比较")]),v._v(" "),_("ol",[_("li",[v._v("G1没有碎片")]),v._v(" "),_("li",[v._v("可以精确的控制停顿, G1将整个堆分为多个固定大小的区域, 每次根据允许停顿的时间去收集垃圾最多的区")])]),v._v(" "),_("h3",{attrs:{id:"对象创建的步骤"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象创建的步骤"}},[v._v("#")]),v._v(" 对象创建的步骤")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("加载类元信息")]),v._v(" "),_("p",[v._v("虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程")])]),v._v(" "),_("li",[_("p",[v._v("为对象分配内存")]),v._v(" "),_("p",[v._v("在"),_("strong",[v._v("类加载检查")]),v._v("通过后，接下来虚拟机将为新生对象"),_("strong",[v._v("分配内存")]),v._v("。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。"),_("strong",[v._v("分配方式")]),v._v("有 "),_("strong",[v._v("“指针碰撞”")]),v._v(" 和 "),_("strong",[v._v("“空闲列表”")]),v._v(" 两种，"),_("strong",[v._v("选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定")]),v._v("。")]),v._v(" "),_("p",[_("strong",[v._v("内存分配的两种方式")]),v._v(" （补充内容，需要掌握）：")]),v._v(" "),_("ul",[_("li",[v._v("指针碰撞 ：\n"),_("ul",[_("li",[v._v("适用场合 ：堆内存规整（即没有内存碎片）的情况下。")]),v._v(" "),_("li",[v._v("原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。")]),v._v(" "),_("li",[v._v("使用该分配方式的 GC 收集器：Serial, ParNew")])])]),v._v(" "),_("li",[v._v("空闲列表 ：\n"),_("ul",[_("li",[v._v("适用场合 ： 堆内存不规整的情况下。")]),v._v(" "),_("li",[v._v("原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。")]),v._v(" "),_("li",[v._v("使用该分配方式的 GC 收集器：CMS")])])])]),v._v(" "),_("p",[v._v('选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。')])]),v._v(" "),_("li",[_("p",[v._v("内存分配并发问题")]),v._v(" "),_("p",[v._v("在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("CAS+失败重试：")]),v._v(" CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。"),_("strong",[v._v("虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。")])]),v._v(" "),_("li",[_("strong",[v._v("TLAB：")]),v._v(" 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配")])])]),v._v(" "),_("li",[_("p",[v._v("属性的默认初始化(零值初始化)")]),v._v(" "),_("p",[v._v("内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。")])]),v._v(" "),_("li",[_("p",[v._v("设置对象头信息")]),v._v(" "),_("p",[v._v("初始化零值完成之后，"),_("strong",[v._v("虚拟机要对对象进行必要的设置")]),v._v("，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 "),_("strong",[v._v("这些信息存放在对象头中。")]),v._v(" 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。")])]),v._v(" "),_("li",[_("p",[v._v("属性的显式初始化、代码块中初始化、构造器中初始化")]),v._v(" "),_("p",[v._v("在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，"),_("code",[v._v("<init>")]),v._v(" 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 "),_("code",[v._v("<init>")]),v._v(" 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来")])])]),v._v(" "),_("p",[_("img",{attrs:{src:a(354),alt:""}})]),v._v(" "),_("h3",{attrs:{id:"对象内存布局"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象内存布局"}},[v._v("#")]),v._v(" 对象内存布局")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("对象头")]),v._v(" "),_("ol",[_("li",[v._v("运行时元数据\n"),_("ol",[_("li",[v._v("哈希值")]),v._v(" "),_("li",[v._v("GC分代年龄")]),v._v(" "),_("li",[v._v("锁状态标志")]),v._v(" "),_("li",[v._v("线程持有的锁")]),v._v(" "),_("li",[v._v("偏向锁id")]),v._v(" "),_("li",[v._v("偏向时间戳")])])]),v._v(" "),_("li",[v._v("类型指针 : 指向类元数据, 确定该对象所属的类型")]),v._v(" "),_("li",[v._v("如果是数组,还要记录数组长度")])])]),v._v(" "),_("li",[_("p",[v._v("实例数据")]),v._v(" "),_("p",[v._v("是对象真正存储的有效信息, 包含程序代码中定义的各个类型的字段(包含自身的父类继承的)")]),v._v(" "),_("ol",[_("li",[v._v("相同宽度的字段总是被分配在一起")]),v._v(" "),_("li",[v._v("父类中定义的变量会在子类之前")]),v._v(" "),_("li",[v._v("如果CompactFields参数为true(默认为true), 子类的窄变量可能插入到父类变量的空隙")])])]),v._v(" "),_("li",[_("p",[v._v("对齐填充: 不是必须的, 也没有特别含义, 起到占位符的作用")])])])])}),[],!1,null,null,null);_.default=i.exports}}]);