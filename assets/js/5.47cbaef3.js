(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{390:function(e,t,a){e.exports=a.p+"assets/img/image-c73ba1ec421b4390a170d220859d4c27.f3e61add.png"},391:function(e,t,a){e.exports=a.p+"assets/img/image-4bbd82caf65e4ecdaa28f8ebcc5ad274.54fb2a57.png"},392:function(e,t,a){e.exports=a.p+"assets/img/image-f566ebe06bad466794ae3ab516d01189.a15bc24b.png"},393:function(e,t,a){e.exports=a.p+"assets/img/image-ba93fcf5eb07406787dc64e4302d7ced.9a37919c.png"},394:function(e,t,a){e.exports=a.p+"assets/img/image-2f3661f1182c4d198589d545d03ede04-20211228215222257.bd87dfe8.png"},395:function(e,t,a){e.exports=a.p+"assets/img/image-0650dc5edfec47c5b59722b884cf1b88.db770c01.png"},396:function(e,t,a){e.exports=a.p+"assets/img/image-5211d35d40884e2fb335161078d1a44d.5530a67e.png"},465:function(e,t,a){"use strict";a.r(t);var r=a(3),i=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"shiro简单使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#shiro简单使用"}},[e._v("#")]),e._v(" shiro简单使用")]),e._v(" "),t("p",[t("strong",[e._v("刚开始工作的时候,需要负责用户模块,所以临时学了一下,记个笔记")]),e._v(" # Shiro的功能")]),e._v(" "),t("p",[t("img",{attrs:{src:a(390),alt:"../../img/other/image-c73ba1ec421b4390a170d220859d4c27.png"}})]),e._v(" "),t("p",[e._v("image.png")]),e._v(" "),t("ul",[t("li",[e._v("Authentication：身份认证，验证用户是否拥有某个身份。")]),e._v(" "),t("li",[e._v("Authorization: 权限校验，验证某个已认证的用户是否拥有某个权限。确定“谁”可以访问“什么”。")]),e._v(" "),t("li",[e._v("Session Management：会话管理，管理用户登录后的会话，")]),e._v(" "),t("li",[e._v("Cryptography：加密，使用密码学加密数据，如加密密码。")]),e._v(" "),t("li",[e._v("Web Support：Web支持，能够比较轻易地整合到Web环境中。")]),e._v(" "),t("li",[e._v("Caching：缓存，对用户的数据进行缓存，")]),e._v(" "),t("li",[e._v("Concurrency：并发，Apache Shiro支持具有并发功能的多线程应用程序，也就是说支持在多线程应用中并发验证。")]),e._v(" "),t("li",[e._v("Testing：测试，提供了测试的支持。")]),e._v(" "),t("li",[e._v("Run as ：允许用户以其他用户的身份来登录。")]),e._v(" "),t("li",[e._v("Remember me ：记住我")])]),e._v(" "),t("h1",{attrs:{id:"依赖包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#依赖包"}},[e._v("#")]),e._v(" 依赖包")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("        <dependency>            <groupId>org.apache.shiro</groupId>            <artifactId>shiro-spring</artifactId>            <version>1.4.0</version>        </dependency>\n")])])]),t("h1",{attrs:{id:"写在前面的话"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#写在前面的话"}},[e._v("#")]),e._v(" 写在前面的话：")]),e._v(" "),t("p",[e._v("springboot中集成shiro相对简单，只需要两个类：一个是shiroConfig类，一个是CustonRealm类。")]),e._v(" "),t("p",[e._v("ShiroConfig类： 顾名思义就是对shiro的一些配置，相对于之前的xml配置。包括：过滤的文件和权限，密码加密的算法，其用注解等相关功能。")]),e._v(" "),t("p",[e._v("CustomRealm类： 自定义的CustomRealm继承AuthorizingRealm。并且重写父类中的doGetAuthorizationInfo（权限相关）、doGetAuthenticationInfo（身份认证）这两个方法。")]),e._v(" "),t("h1",{attrs:{id:"简单实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单实现"}},[e._v("#")]),e._v(" 简单实现")]),e._v(" "),t("p",[t("img",{attrs:{src:a(391),alt:"../../img/other/image-4bbd82caf65e4ecdaa28f8ebcc5ad274.png"}})]),e._v(" "),t("p",[e._v("image.png")]),e._v(" "),t("p",[e._v("共需要5个文件")]),e._v(" "),t("p",[e._v("CustomRealm: 自定义的认证源, 身份认证和权限认证")]),e._v(" "),t("p",[e._v("OAuthToken: token实体类")]),e._v(" "),t("p",[e._v("ShiroConfig: shiro的一些配置，相对于之前的xml配置。包括：过滤的文件和权限，密码加密的算法，其用注解等相关功能")]),e._v(" "),t("p",[e._v("TestFilter 自定义过滤器")]),e._v(" "),t("p",[e._v("TokenGenerator token生成器, 测试功能流程的话可以不用这个, 实际中生成token的逻辑")]),e._v(" "),t("h2",{attrs:{id:"自定义令牌实体类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义令牌实体类"}},[e._v("#")]),e._v(" 自定义令牌实体类")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("package com.atguigu.gulimall.shiro_demo.config;import org.apache.shiro.authc.AuthenticationToken;/** * @author zhangshaokun * @date 2021/3/11 * 自定义令牌实体类 */public class OAuthToken implements AuthenticationToken {        private String token;        public OAuthToken(String token){            this.token = token;        }        @Override        public String getPrincipal() {            return token;        }        @Override        public Object getCredentials() {            return token;        }    }\n")])])]),t("h2",{attrs:{id:"token生成器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#token生成器"}},[e._v("#")]),e._v(" token生成器")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package com.atguigu.gulimall.shiro_demo.demo;import java.security.MessageDigest;import java.util.UUID;/** * 生成token * */public class TokenGenerator {    public static String generateValue() {        return generateValue(UUID.randomUUID().toString());    }    private static final char[] hexCode = "0123456789abcdef".toCharArray();    public static String toHexString(byte[] data) {        if(data == null) {            return null;        }        StringBuilder r = new StringBuilder(data.length*2);        for ( byte b : data) {            r.append(hexCode[(b >> 4) & 0xF]);            r.append(hexCode[(b & 0xF)]);        }        return r.toString();    }    public static String generateValue(String param) {        try {            MessageDigest algorithm = MessageDigest.getInstance("MD5");            algorithm.reset();            algorithm.update(param.getBytes());            byte[] messageDigest = algorithm.digest();            return toHexString(messageDigest);        } catch (Exception e) {            // 这个可具体更改,现在做例子不动了,可以自定义异常类进行抛出提醒            throw new RuntimeException("生成Token失败", e);        }    }}\n')])])]),t("h2",{attrs:{id:"customrealm类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#customrealm类"}},[e._v("#")]),e._v(" CustomRealm类")]),e._v(" "),t("p",[e._v("自定义认证源")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package com.atguigu.gulimall.shiro_demo.demo;import org.apache.shiro.authc.*;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;/** * @author zhangshaokun * @date 2021/3/11 */@Componentpublic class CustomRealm extends AuthorizingRealm {    @Override    public boolean supports(AuthenticationToken token) {        return token instanceof OAuthToken;    }    /**     * 权限认证，即登录过后，每个身份不一定，对应的所能看的页面也不一样     * */    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {        //这个里面存储的是主要身份信息,来源便是下面身份认证最后存入的第一个参数        Object primaryPrincipal = principalCollection.getPrimaryPrincipal();        //利用这些信息,便能从数据库或者其他位置获取权限列表了,具体实现略        //获取用户的权限列表,存入set中        Set<String> permsSet = new HashSet<>();        //授权信息实例        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();        //传入一个set        info.setStringPermissions(permsSet);        return info;    }    /**     * 身份认证。即登录通过账号和密码验证登陆人的身份信息     * */    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {        //获取token        String token = (String) authenticationToken.getPrincipal();        //通过token获取用户信息, 比如token和用户信息存储在redis或数据库, 那么便根据token去查询        //这里用map模拟数据库        Map<String, String> token_value = new HashMap<>();        token_value.put("6110e95350b2af23be9c70b93d0c118f","张三");        token_value.put("token2","李四");        //判断是否读取到信息        String value = token_value.get(token);        //如果没有查询到信息,或者token设置的时间已经过期        if (StringUtils.isEmpty(value)){            System.out.println("token失效，请重新登录");            throw new IncorrectCredentialsException("token失效，请重新登录");        }        //token有效, 就查询用户的详细信息        //还可以在做一些判断,比如用户有没有被注销,被封禁等等        //具体实现略        String str = "";  //这个只是临时传参避免报错的        // 将用户信息(具体类型看需求,可以是简单的string也可以是对象,要方便上面权限认证是容易获取用户信息), token 传入        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(str, token, getName());        return info;    }}\n')])])]),t("h2",{attrs:{id:"shiroconfig类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#shiroconfig类"}},[e._v("#")]),e._v(" ShiroConfig类")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package com.atguigu.gulimall.shiro_demo.demo;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.servlet.Filter;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.Map;/** * @author zhangshaokun * @date 2021/3/11 */@Configurationpublic class ShiroConfig {    /*随记: 根据三个方法的引用顺序排了序*/    /*这里CustomRealm类没有加注解注册到spring框架,所以方法new出来返回的,如果类上加了,这里可以省略这个方法    * 比如给CustomRealm类用Component注解进行注册后, 直接向securityManager(CustomRealm customRealm)方法中传参即可,如下*//*    @Bean    public CustomRealm customRealm() {        CustomRealm customRealm = new CustomRealm();        return customRealm;    }*/    /*SecurityManger:SecurityManager是Shiro核心，主要协调Shiro内部的各种安全组件，这个我们不需要太关注，只需要知道可以设置自定的Realm*/    @Bean("securityManager")    public SecurityManager securityManager(CustomRealm customRealm) {        DefaultWebSecurityManager defaultSecurityManager = new DefaultWebSecurityManager();        //存入Realm        defaultSecurityManager.setRealm(customRealm);        return defaultSecurityManager;    }    /*bean名称必须是shiroFilter*/    @Bean("shiroFilter")    public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) {        //创建一个shiroFilter实例        ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();        //配置Manager        shiroFilter.setSecurityManager(securityManager);        //自定义过滤规则,可以自定义多个, 通过map传入        Map<String, Filter> filters = new HashMap<>();        //第一个参数过滤器, 第二个参数是具体的过滤器实例        filters.put("oauth2", new TestFilter());        //将自定义的过滤器加入shiroFilter中        shiroFilter.setFilters(filters);        //设置登录路径,设置后登录路径下不走认证,也可以用下面kv的形式写入        shiroFilter.setLoginUrl("/login");        //设置权限不足是跳转页面        shiroFilter.setUnauthorizedUrl("/notRole");        //上面两个方法不能很全面,所以可以通过LinkedHashMap向过滤器传入过滤配置, 因为存入的规则是有序的        Map<String, String> filterMap = new LinkedHashMap<>();        //第一个参数是路径, 第二个参数字典值,标识过滤规则        //authc:所有url都必须认证通过才可以访问; anon:所有url都都可以匿名访问        //需要注意匹配按照上下顺序来的,  如果/**写在最前面那么,后面的都被覆盖了        filterMap.put("/sys/login","anon");  //这个的意思就是 /sys/login 可以匿名访问不进行认证        filterMap.put("/swagger/**", "anon"); //可以用**进行匹配所有子路径        filterMap.put("/swagger-ui.html", "anon");  //也可以是静态文件        filterMap.put("/admin/**", "authc");  //admin下所有都必须通过认证才能访问        filterMap.put("/test/**", "oauth2");  //还可以指定自定义的过滤规则        filterMap.put("/**", "oauth2");        //将上面配置的kv存入        shiroFilter.setFilterChainDefinitionMap(filterMap);        //返回        return shiroFilter;    }}\n')])])]),t("h2",{attrs:{id:"filter类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#filter类"}},[e._v("#")]),e._v(" filter类")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('package com.atguigu.gulimall.shiro_demo.demo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.web.filter.authc.AuthenticatingFilter;import org.springframework.util.StringUtils;import javax.servlet.http.HttpServletRequest;/** * @author zhangshaokun * @date 2021/3/11 * 自定义的过滤器 */public class TestFilter extends AuthenticatingFilter{    @Override    protected AuthenticationToken createToken(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse) throws Exception {        //获取请求token        String token = getRequestToken((HttpServletRequest) servletRequest);        //如果携带没有携带token,则返回null        if(StringUtils.isEmpty(token)){            return null;        }        //携带了token便返回自定义的token实例        return new OAuthToken(token);    }    @Override    protected boolean onAccessDenied(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse) throws Exception {        //获取请求token        String token = getRequestToken((HttpServletRequest) servletRequest);        //如果不存在返回401, 这里简化为输出,实际中要给前端返回401及其他错误信息        if(StringUtils.isEmpty(token)){            System.out.println("错误401:token为空");            return false;        }        return executeLogin(servletRequest, servletResponse);    }    /**     * 获取请求中的token     */    private String getRequestToken(HttpServletRequest httpRequest){        //从header中获取token        String token = httpRequest.getHeader("token");        //如果header中不存在token，则从参数中获取token        if(StringUtils.isEmpty(token)){            token = httpRequest.getParameter("token");        }        return token;    }}\n')])])]),t("h1",{attrs:{id:"自定义认证时流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义认证时流程"}},[e._v("#")]),e._v(" 自定义认证时流程")]),e._v(" "),t("p",[e._v("参考链接: https://blog.csdn.net/long270022471/article/details/62423286")]),e._v(" "),t("h2",{attrs:{id:"_1-首先根据config中路径匹配到对应的自定义filter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-首先根据config中路径匹配到对应的自定义filter"}},[e._v("#")]),e._v(" 1.首先根据config中路径匹配到对应的自定义filter")]),e._v(" "),t("p",[t("img",{attrs:{src:a(392),alt:"../../img/other/image-f566ebe06bad466794ae3ab516d01189.png"}})]),e._v(" "),t("p",[e._v("image.png")]),e._v(" "),t("h2",{attrs:{id:"_2-filter中首先进入onaccessdenied方法-判断请求有没有token"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-filter中首先进入onaccessdenied方法-判断请求有没有token"}},[e._v("#")]),e._v(" 2.filter中首先进入onAccessDenied方法,判断请求有没有token")]),e._v(" "),t("p",[t("img",{attrs:{src:a(393),alt:"../../img/other/image-ba93fcf5eb07406787dc64e4302d7ced.png"}})]),e._v(" "),t("p",[e._v("image.png")]),e._v(" "),t("h2",{attrs:{id:"_3-存在token时便进入executelogin-进行登录步骤-其中会调用filter中的重写的createtoken方法获取token实例-调用subject-login-token-进行具体登录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-存在token时便进入executelogin-进行登录步骤-其中会调用filter中的重写的createtoken方法获取token实例-调用subject-login-token-进行具体登录"}},[e._v("#")]),e._v(" 3.存在token时便进入executeLogin()进行登录步骤 ,其中会调用filter中的重写的createToken方法获取token实例, 调用subject.login(token)进行具体登录")]),e._v(" "),t("p",[t("img",{attrs:{src:a(394),alt:"../../img/other/image-2f3661f1182c4d198589d545d03ede04-20211228215222257.png"}})]),e._v(" "),t("p",[e._v("image.png")]),e._v(" "),t("h2",{attrs:{id:"_4-跟随参考链接中的具体流程走回到这一步-用到了我们在realm中重写的supports方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-跟随参考链接中的具体流程走回到这一步-用到了我们在realm中重写的supports方法"}},[e._v("#")]),e._v(" 4.跟随参考链接中的具体流程走回到这一步,用到了我们在Realm中重写的supports方法")]),e._v(" "),t("p",[t("img",{attrs:{src:a(395),alt:"../../img/other/image-0650dc5edfec47c5b59722b884cf1b88.png"}})]),e._v(" "),t("p",[e._v("image.png")]),e._v(" "),t("h2",{attrs:{id:"_5-认证这一步深入便会进入重写的身份认证方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-认证这一步深入便会进入重写的身份认证方法"}},[e._v("#")]),e._v(" 5.认证这一步深入便会进入重写的身份认证方法")]),e._v(" "),t("p",[t("img",{attrs:{src:a(396),alt:"../../img/other/image-5211d35d40884e2fb335161078d1a44d.png"}})]),e._v(" "),t("p",[e._v("image.png")])])}),[],!1,null,null,null);t.default=i.exports}}]);