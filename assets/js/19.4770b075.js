(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{331:function(t,e,s){"use strict";s.r(e);var a=s(3),n=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"原型模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型模式"}},[t._v("#")]),t._v(" 原型模式")]),t._v(" "),e("p",[t._v("是指创建新对象的时候，根据现有的一个原型来创建。")]),t._v(" "),e("p",[t._v("平时我们说的对象克隆就是一个原型模式,用于同一个资源需要使用多次,每次修改不影响的情景下")]),t._v(" "),e("p",[t._v("比如获取一套题库,然后打乱是顺序发给每个人,那我们只需要获取一次初始题库然后clone出一份新的再打乱顺序")]),t._v(" "),e("p",[t._v("实际上，使用原型模式更好的方式是定义一个"),e("code",[t._v("copy()")]),t._v("方法，返回明确的类型：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("public class Student {    private int id;    private String name;    private int score;    public Student copy() {        Student std = new Student();        std.id = this.id;        std.name = this.name;        std.score = this.score;        return std;    }}\n")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);