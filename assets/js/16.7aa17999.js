(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{330:function(t,s,a){"use strict";a.r(s);var e=a(3),v=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"redis"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[t._v("#")]),t._v(" Redis")]),t._v(" "),s("p",[t._v("redis和memoryCache的对比: redis支持持久化, 当内存中数据丢失时可通过持久化方式恢复")]),t._v(" "),s("h1",{attrs:{id:"五种数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五种数据类型"}},[t._v("#")]),t._v(" 五种数据类型")]),t._v(" "),s("p",[t._v("String 字符串")]),t._v(" "),s("p",[t._v("Hash 面向对象的结构")]),t._v(" "),s("p",[t._v("List 双向链表")]),t._v(" "),s("p",[t._v("Set 集合")]),t._v(" "),s("p",[t._v("ZSet 有序集合")]),t._v(" "),s("p",[t._v("bitmap  位图")]),t._v(" "),s("p",[t._v("HyperLogLog  统计")]),t._v(" "),s("p",[t._v("GEO  地理位置")]),t._v(" "),s("p",[t._v("Stream")]),t._v(" "),s("h1",{attrs:{id:"常用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常用场景"}},[t._v("#")]),t._v(" 常用场景")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("string：\n简单地 get / set 缓存。")]),t._v(" "),s("p",[t._v("做计数, 点赞数等等")])]),t._v(" "),s("li",[s("p",[t._v("hash：")]),t._v(" "),s("p",[t._v("可以缓存用户资料。比如命令：hmset user1 name “lin” sex “male” age “25” ，缓存用户 user1 的资料，姓名为 lin ，性别为男，年龄 25。")]),t._v(" "),s("p",[t._v("map<String, map<>>")])]),t._v(" "),s("li",[s("p",[t._v("list：")]),t._v(" "),s("p",[t._v("可以做队列。往 list 队列里面 push 数据，然后再 pop 出来。")]),t._v(" "),s("p",[t._v("比如订阅号列表, 关注人的信息推送到我的列表")])]),t._v(" "),s("li",[s("p",[t._v("zset：")]),t._v(" "),s("p",[t._v("可以用来做排行榜。")])]),t._v(" "),s("li",[s("p",[t._v("set:")]),t._v(" "),s("p",[t._v("微信的点赞用户")]),t._v(" "),s("p",[t._v("抽奖参与用户  可以不重复的保存参与用户id, 还可以从中随机抽取中奖者")]),t._v(" "),s("p",[t._v("社交圈: 可以求两个人的交集  微博共同关注的人")]),t._v(" "),s("p",[t._v("推测可能认识的人: 求差集")]),t._v(" "),s("p",[t._v("和list的区别就是, 不能有重复的元素, 可以用来存储某个人所有的关注者id")])])]),t._v(" "),s("h1",{attrs:{id:"常用命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常用命令"}},[t._v("#")]),t._v(" 常用命令")]),t._v(" "),s("p",[t._v("set key value 存储key-value结构的数据")]),t._v(" "),s("p",[t._v("get key 获取对应key的value")]),t._v(" "),s("p",[t._v("keys * 查看所有的key")]),t._v(" "),s("p",[t._v("exists key 判断这个key是否存在")]),t._v(" "),s("p",[t._v("del key 删除这个key")]),t._v(" "),s("p",[t._v("type key 查看key的类型")]),t._v(" "),s("p",[t._v("save 将当前内存的数据持久化 根目录的dump.db")]),t._v(" "),s("p",[t._v("flushall 会将当前redis所有数据清空包括持久化数据")]),t._v(" "),s("p",[t._v("fludb 清空一个分库的数据,不删除持久化数据")]),t._v(" "),s("p",[t._v("mset/mget 批量操作")]),t._v(" "),s("p",[t._v("expire key 可以对key添加超时过期的设定")]),t._v(" "),s("p",[t._v("ttl key 可以查看key剩余时间, -2是超时 -1是永久数据")]),t._v(" "),s("h3",{attrs:{id:"string类型的操作命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#string类型的操作命令"}},[t._v("#")]),t._v(" String类型的操作命令")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/other/image-14b931f9bd654ff9a53be611bc0b9c65.png",alt:"/img/other/image-14b931f9bd654ff9a53be611bc0b9c65.png"}})]),t._v(" "),s("h3",{attrs:{id:"list类型的操作命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#list类型的操作命令"}},[t._v("#")]),t._v(" List类型的操作命令")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/other/image-4772d735d78f4247ac3ff410b66fedb5.png",alt:"/img/other/image-4772d735d78f4247ac3ff410b66fedb5.png"}})]),t._v(" "),s("h3",{attrs:{id:"set类型的操作命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#set类型的操作命令"}},[t._v("#")]),t._v(" Set类型的操作命令")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/other/image-0d55cc887d794685a46325cb27554934.png",alt:"/img/other/image-0d55cc887d794685a46325cb27554934.png"}})]),t._v(" "),s("h3",{attrs:{id:"hash类型的操作命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hash类型的操作命令"}},[t._v("#")]),t._v(" Hash类型的操作命令")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/other/image-506e300dd397497cbe99be66bb2ffeab.png",alt:"/img/other/image-506e300dd397497cbe99be66bb2ffeab.png"}})]),t._v(" "),s("h3",{attrs:{id:"zset类型的操作命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#zset类型的操作命令"}},[t._v("#")]),t._v(" Zset类型的操作命令")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/other/image-6500961541b340bebb0059d8c382f12a.png",alt:"/img/other/image-6500961541b340bebb0059d8c382f12a.png"}})]),t._v(" "),s("h1",{attrs:{id:"redis分布式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis分布式"}},[t._v("#")]),t._v(" redis分布式")]),t._v(" "),s("p",[t._v("分布式中数据分片计算:hash取余, hash一致性")]),t._v(" "),s("p",[t._v("hash取余: 对key的hash值进行取余,再映射到redis节点上")]),t._v(" "),s("p",[t._v("hash一致性: 散列计算,一个0-43亿的hash环, 将 redis节点映射到hash环上, key也映射到hash环上, key值顺时针寻找最近节点做映射")]),t._v(" "),s("h1",{attrs:{id:"redis的优势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis的优势"}},[t._v("#")]),t._v(" redis的优势")]),t._v(" "),s("ol",[s("li",[t._v("速度快, 因为数据都是存储在内存中")]),t._v(" "),s("li",[t._v("支持丰富的数据类型, string, list, set, zset, hash")]),t._v(" "),s("li",[t._v("支持事务, 操作都是原子性, 所谓的原子性就是对数据的更改要么全部执行, 要不不执行")]),t._v(" "),s("li",[t._v("丰富的特性: 可用于缓存, 消息, 按照key设置过期时间, 过期后将会自动删除.")]),t._v(" "),s("li",[t._v("单线程, 单进程, 采用IO多路复用技术")])]),t._v(" "),s("h1",{attrs:{id:"redis可靠性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis可靠性"}},[t._v("#")]),t._v(" redis可靠性")]),t._v(" "),s("p",[t._v("redis可靠性也就是数据持久化的问题")]),t._v(" "),s("p",[t._v("redis持久化分为"),s("strong",[t._v("AOF")]),t._v("和"),s("strong",[t._v("RDB")]),t._v("两种形式,")]),t._v(" "),s("p",[t._v("AOF : 是备份操作记录. 因为是备份操作命令, 所以备份快 , 恢复慢")]),t._v(" "),s("p",[t._v("RDB: 是快照的形式, 备份所有数据. 恢复数据比较快")]),t._v(" "),s("p",[t._v("优缺点:")]),t._v(" "),s("p",[s("strong",[t._v("AOF")]),t._v(": 日志的形式, 记录详细最多丢失一秒内的数据. 但是因为是日志级所以进程会持续进行可能占用资源, 恢复是需要根据日志操作进行恢复比较慢. 日志文件大")]),t._v(" "),s("p",[s("strong",[t._v("RDB")]),t._v(": 快照的形式, 在设置的时间间隔内进行快照保存, 如果间隔时间过久则会丢失过多的数据. 一次保存是备份所有数据, 比较慢 ;但是由于保存的是数据的最新状态, 恢复时速度快")]),t._v(" "),s("p",[s("strong",[t._v("AOF文件重写")]),t._v(": 由于AOF文件会越来越大, 里面会存在大量的重复命令或者可以合并的命令. 重写可以减少日志的尺寸, 减少占用, 加快数据恢复速度")]),t._v(" "),s("h1",{attrs:{id:"redis的过期策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis的过期策略"}},[t._v("#")]),t._v(" redis的过期策略")]),t._v(" "),s("p",[t._v("惰性删除: 当读写到这个过期的key时, 会触发惰性删除策略, 直接删除这个过期的key , 并按照key不存在处理. 过期的key如果没有触发会占用内存")]),t._v(" "),s("p",[t._v("定期删除: 每隔一段时间就会对redis进行检查, 主动删除过期的key")]),t._v(" "),s("p",[t._v("定时删除: 给每个key设置时间时, 为key创建一个定时器, 让定时器在key过期时执行删除")]),t._v(" "),s("h1",{attrs:{id:"内存淘汰策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存淘汰策略"}},[t._v("#")]),t._v(" 内存淘汰策略")]),t._v(" "),s("p",[t._v("当已用内存超过 maxmemory 限定时, 会触发主动清理策略, 也就是redis的内存回收/淘汰策略")]),t._v(" "),s("ol",[s("li",[t._v("noeviction(默认的) : 不会驱逐任何key")]),t._v(" "),s("li",[t._v("allkeys-lru(常用): 对所有key使用LRU算法进行删除, 最近不常用的")]),t._v(" "),s("li",[t._v("volatile-lru: 对所有设置了过期时间的key使用LRU算法进行删除")]),t._v(" "),s("li",[t._v("allkeys-random: 对所有key随机删除")]),t._v(" "),s("li",[t._v("volatile-random: 对所有设置了过期时间的key随机删除")]),t._v(" "),s("li",[t._v("volatile-ttl: 删除马上要过期的key")]),t._v(" "),s("li",[t._v("allkeys-lfu: 对所有key使用LFU算法进行删除")]),t._v(" "),s("li",[t._v("volatile-lfu: 对所有设置了过期时间的key使用LFU算法进行删除")])]),t._v(" "),s("p",[t._v("怎么配置修改?")]),t._v(" "),s("p",[t._v("config set maxmemory-policy allkeys-lru  或者 修改配置文件")]),t._v(" "),s("h1",{attrs:{id:"lru算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lru算法"}},[t._v("#")]),t._v(" LRU算法")]),t._v(" "),s("p",[t._v("Least Recently Used 的缩写, 即最近最少使用, 是一种常用的页面置换算法")]),t._v(" "),s("p",[t._v("选择最近最久未使用的数据予以淘汰")]),t._v(" "),s("p",[t._v("算法思想:")]),t._v(" "),s("ol",[s("li",[t._v("所谓缓存, 必须要有读+写两个操作, 按照命中率的思想考虑, 写操作+读操作时间复杂度都需要为0(1)")]),t._v(" "),s("li",[t._v("特性要求\n"),s("ol",[s("li",[t._v("必须要有顺序之分, 一区分最近使用的和很久没有使用的数据排序")]),t._v(" "),s("li",[t._v("写和读操作一次搞定")]),t._v(" "),s("li",[t._v("如果容量满了要删除最不常用的数据, 每次新访问还要把新数据插入到队头")])])])]),t._v(" "),s("p",[t._v("查找快、插入快、删除快,还有先后顺序")]),t._v(" "),s("p",[t._v("哈希链表  查找用哈希, 增删用链表")]),t._v(" "),s("p",[t._v("手写算法   "),s("a",{attrs:{href:"https://leetcode-cn.com/problems/lru-cache/",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://leetcode-cn.com/problems/lru-cache/"),s("OutboundLink")],1)]),t._v(" "),s("h1",{attrs:{id:"redis的搭建模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis的搭建模式"}},[t._v("#")]),t._v(" redis的搭建模式")]),t._v(" "),s("p",[t._v("主从模式, 哨兵模式, 集群模式")]),t._v(" "),s("h1",{attrs:{id:"redis集群数据分片原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis集群数据分片原理"}},[t._v("#")]),t._v(" redis集群数据分片原理")]),t._v(" "),s("p",[t._v("redis的数据分片原理是哈希槽")]),t._v(" "),s("p",[t._v("redis集群有16384个槽道, 每个节点承担其中一部分")]),t._v(" "),s("p",[t._v("哈希槽让在集群中增删节点变得容易, 只需要进行槽道的转移即可")]),t._v(" "),s("h1",{attrs:{id:"hash一致性算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hash一致性算法"}},[t._v("#")]),t._v(" hash一致性算法")]),t._v(" "),s("p",[t._v("一致性算法将整个hash值控件组织成一个虚拟的圆环, 我们对key进行哈希计算, 使用哈希后的结果对2 ^ 32取模, hash环上必定有一个点与之对应, 依次确定此数据在环上的位置, 从此位置顺时针找到的第一台机器便是其应该定位到的服务器")]),t._v(" "),s("p",[t._v("节点的增删只会影响定位环中相邻的一小部分数据, 具有较好的容错性和可扩展性")]),t._v(" "),s("h1",{attrs:{id:"为啥redis集群分片没有使用hash一致性算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为啥redis集群分片没有使用hash一致性算法"}},[t._v("#")]),t._v(" 为啥redis集群分片没有使用hash一致性算法?")]),t._v(" "),s("p",[t._v("hash一致性有个问题就是数据倾斜.")]),t._v(" "),s("p",[t._v("如果节点太少,并且分布不均匀, 会造成节点间数据不均的问题")]),t._v(" "),s("p",[t._v("虚拟节点可以解决")]),t._v(" "),s("h1",{attrs:{id:"集群的拓扑结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#集群的拓扑结构"}},[t._v("#")]),t._v(" 集群的拓扑结构")]),t._v(" "),s("p",[t._v("无中心结构, 每个节点保存数据和整个集群的状态, 每个节点都和其他所有节点连接")]),t._v(" "),s("h1",{attrs:{id:"redis数据更新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis数据更新"}},[t._v("#")]),t._v(" redis数据更新")]),t._v(" "),s("p",[t._v("当数据库数据需要更新时, 是先更新redis还是先更新数据库呢?")]),t._v(" "),s("p",[t._v("先更新数据库再更新缓存, 这样无论哪一步出现问题,最多用户拿到旧数据")]),t._v(" "),s("p",[t._v("从并发情况和数据一致性进行分析:")]),t._v(" "),s("p",[t._v("如果两步都没有出错, 那么先更新数据库不会有一致性问题, 而先更新缓存在并发情况下会出现一致性问题")]),t._v(" "),s("p",[t._v("如果两步中有其中一步出错, …")]),t._v(" "),s("p",[t._v("先更新数据库加过期时间比较好")]),t._v(" "),s("h1",{attrs:{id:"什么数据适合放在redis中"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么数据适合放在redis中"}},[t._v("#")]),t._v(" 什么数据适合放在redis中?")]),t._v(" "),s("p",[t._v("个人认为:")]),t._v(" "),s("p",[t._v("1.使用频繁的数据, 比如所有用户首页都展示活动信息或者频繁查询的重复数据, 更新不频繁但查询频繁的数据")]),t._v(" "),s("h1",{attrs:{id:"redis实现分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis实现分布式锁"}},[t._v("#")]),t._v(" redis实现分布式锁")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('//普通命令SET lock_key random_value NX PX 5000//通过连接池使用redisPool.getResource().set("test02","测试2",SetParams.setParams().nx().px(5000));\n')])])]),s("p",[t._v("NX表示只有键不存在时，才对键进行设置操作")]),t._v(" "),s("p",[t._v("PX 5000 设置过期时间")]),t._v(" "),s("h2",{attrs:{id:"使用redisson实现分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用redisson实现分布式锁"}},[t._v("#")]),t._v(" 使用redisson实现分布式锁")]),t._v(" "),s("p",[t._v("redisson实现分布式锁更优,它结合了java中lock本地锁,自动设置锁30s存活,并且看门狗自动锁续约,使用更方便")]),t._v(" "),s("p",[t._v("解锁时尽量判断一下")]),t._v(" "),s("p",[s("img",{attrs:{src:"/img/redis/1.png",alt:""}})]),t._v(" "),s("h1",{attrs:{id:"redis的内存穿透"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis的内存穿透"}},[t._v("#")]),t._v(" redis的内存穿透")]),t._v(" "),s("p",[t._v("redis缓存穿透是因为当查询一个一定不存在的数据时, 由于缓存中不命中便会查询数据库, 查不到数据就不写入缓存, 这样每次查这个不存在的数据都会去查数据库, 造成缓存穿透.")]),t._v(" "),s("p",[t._v("解决方法:")]),t._v(" "),s("p",[t._v("1.布隆过滤")]),t._v(" "),s("p",[t._v("对所有可能查询的参数以hash形式存储, 在控制层进行校验, 不符合则丢弃. 常见的还有使用布隆过滤器, 将所有可能存在的数据hash到一个bitmap中, 一个一定不存在的数据会被bitmap拦截掉, 从而避免对底层存储的查询")]),t._v(" "),s("p",[t._v("2.缓存空对象")]),t._v(" "),s("p",[t._v("当查询为空时, 将这个空对象进行缓存 , 过期时间给短一些")]),t._v(" "),s("h1",{attrs:{id:"缓存击穿"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[t._v("#")]),t._v(" 缓存击穿")]),t._v(" "),s("p",[t._v("key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。")]),t._v(" "),s("p",[t._v("解决方法:")]),t._v(" "),s("p",[t._v("1.使用互斥锁(mutex key)")]),t._v(" "),s("p",[t._v("当判断失效时(value为null), 不立即去读数据库, 使用redis的SETNX存储一个标识key, 如果存储成功了, 则读数据库, 写入缓存, 删除这个标识key ; 如果存储标识key失败了, 意味着有其他线程已经在做读库操作了, 让当前线程sleep一段时间后重试")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" value "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" redis"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//代表缓存值过期")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db")]),t._v("\n\t\t      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("redis"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setnx")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key_mutex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  \n\t\t\t\t\t\t\t "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//代表设置成功")]),t._v("\n               value "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" db"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n               redis"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" expire_secs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n               redis"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("del")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key_mutex"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  \n              "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可")]),t._v("\n\t             "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sleep")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("50")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n               "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//重试")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n              "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n     "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h1",{attrs:{id:"缓存雪崩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[t._v("#")]),t._v(" 缓存雪崩")]),t._v(" "),s("p",[t._v("与击穿的区别在于,是大量的key失效, 一旦缓存大量丢失缓存数据,就造成海量请求瞬间进入数据库,导致数据库崩溃–雪崩;redis出现雪崩,只需要恢复数据(持久化),memoryCache出现雪崩,只能停止服务手动将数据恢复到内存中,继续提供服务")]),t._v(" "),s("p",[t._v("解决方法:")]),t._v(" "),s("p",[t._v("1.线程加锁, 但是对出现一线程执行多线程等待 , 影响并发")]),t._v(" "),s("p",[t._v("2.在原有失效时间上加个随机值, 让每个key的过期时间尽量错开, 避免集体失效")]),t._v(" "),s("p",[t._v("3.做二级缓存, 或者双缓存机制 做两份缓存A和B, B不设失效时间, 这样当A失效后拿B的数据去返回, 同时异步启动一个更新线程, 将更新的数据同步到A和B")]),t._v(" "),s("h1",{attrs:{id:"其余"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其余"}},[t._v("#")]),t._v(" 其余")]),t._v(" "),s("p",[t._v("https://mp.weixin.qq.com/s/TZ6sRuiClFJf6tMKE0Cq7w")])])}),[],!1,null,null,null);s.default=v.exports}}]);