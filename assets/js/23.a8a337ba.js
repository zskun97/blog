(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{337:function(e,t,v){"use strict";v.r(t);var _=v(3),a=Object(_.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"享元模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#享元模式"}},[e._v("#")]),e._v(" 享元模式")]),e._v(" "),t("h3",{attrs:{id:"定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[e._v("#")]),e._v(" 定义")]),e._v(" "),t("p",[e._v("享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。")]),e._v(" "),t("p",[e._v("享元模式在Java标准库中有很多应用。我们知道，包装类型如"),t("code",[e._v("Byte")]),e._v("、"),t("code",[e._v("Integer")]),e._v("都是不变类，因此，反复创建同一个值相同的包装类型是没有必要的。以"),t("code",[e._v("Integer")]),e._v("为例，如果我们通过"),t("code",[e._v("Integer.valueOf()")]),e._v("这个静态工厂方法创建"),t("code",[e._v("Integer")]),e._v("实例，当传入的"),t("code",[e._v("int")]),e._v("范围在"),t("code",[e._v("-128")]),e._v("~"),t("code",[e._v("+127")]),e._v("之间时，会直接返回缓存的"),t("code",[e._v("Integer")]),e._v("实例")]),e._v(" "),t("p",[e._v("上面我们工厂模式, 通过注解获取对象bean,然后存入map, 每次获取都从map获取而不是新new")])])}),[],!1,null,null,null);t.default=a.exports}}]);